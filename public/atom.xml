<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>连思鑫的知识库</title>
  
  <subtitle>知识改变命运</subtitle>
  <link href="https://jinbilianshao.github.io/atom.xml" rel="self"/>
  
  <link href="https://jinbilianshao.github.io/"/>
  <updated>2023-03-06T12:52:11.343Z</updated>
  <id>https://jinbilianshao.github.io/</id>
  
  <author>
    <name>连思鑫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vi使用教程</title>
    <link href="https://jinbilianshao.github.io/wiki/vi%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-1/"/>
    <id>https://jinbilianshao.github.io/wiki/vi%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-1/</id>
    <published>2023-03-06T07:05:00.000Z</published>
    <updated>2023-03-06T12:52:11.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、关于vi"><a href="#一、关于vi" class="headerlink" title="一、关于vi"></a>一、关于vi</h1><p>vi是最强大的文本编辑器，没有之一。</p><p>尽管vi已经是古董级的软件，但还是有无数新人迎着困难去学习使用，可见其经典与受欢迎的程度。</p><p>无论是小说中还是电视剧，真正强大的武器都不容易驾驭，需要付出一些努力才能收获到更加强大的力量，对于vi这种上古神器来说更是如此。</p><p>由于它全程使用键盘操作，很多首次接触 vi的人会觉得不习惯而中途放弃。然而，坚持下来的朋友就会渐渐地发现这种键盘操作的设计绝妙，经典之所以能成为经典，必然有它的道理，不用解释太多。</p><p>观察一个程序员对vi的熟练程度，可以判断它的技术水平，如果他对vi不熟悉，就肯定不是Linux平台下的程序员，说vi不好用的人也肯定不熟悉vi和Linux，没有例外。</p><h1 id="二、创建-打开文件"><a href="#二、创建-打开文件" class="headerlink" title="二、创建/打开文件"></a>二、创建/打开文件</h1><p>vi 文件名</p><p>打开一个文件，如果文件不存在，就创建它。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi book.c</span><br></pre></td></tr></table></figure><h1 id="三、vi的三种模式"><a href="#三、vi的三种模式" class="headerlink" title="三、vi的三种模式"></a>三、vi的三种模式</h1><p>vi 有三种模式：</p><ol><li>命令行模式</li><li>插入模式</li><li>替换模式</li></ol><p>在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。</p><p>插入模式和替换模式也合称为编辑模式。</p><h1 id="四、vi的常用命令"><a href="#四、vi的常用命令" class="headerlink" title="四、vi的常用命令"></a>四、vi的常用命令</h1><p><code>Esc</code> ：从编辑模式切换到命令行模式。</p><p><code>i</code> ：在光标所在位置前面开始插入。</p><p><code>a</code>    ： 在光标所在的位置后面开始插入。</p><p><code>o</code> ：在光标所在位置行的下面插入空白行。</p><p><code>O</code> ：在光标所在位置行的上面插入空白行。</p><p><code>I</code> ：在光标所在位置行的行首开始插入。</p><p><code>A</code> ：在光标所在位置行的行末开始插入。</p><p><code>k</code> ：类似方向键上。</p><p><code>j</code> ：类似方向键下。</p><p><code>h</code> ：类似方向键左。</p><p><code>l</code> ：类是方向键右。</p><p><code>Ctrl+u</code> ：向上翻半页。</p><p><code>Ctrl+d</code> ：向下翻页。</p><p><code>Ctrl+g</code> ：显示光标所在位置的行号和文件的总行数。</p><p><code>nG</code> ：光标跳到文件的第n行行首。</p><p><code>G</code>     光标跳到文件最后一行。</p><p><code>:5回车</code>   光标跳到第5行。</p><p><code>:n回车</code>   光标跳到第n行。</p><p><code>0</code> ：光标跳到当前行的行首。</p><p><code>$</code> ：光标跳到当前行的行尾。</p><p><code>w</code> ：光标跳到下个单词的开头。</p><p><code>b</code> ：光标跳到上个单词的开头。</p><p><code>e</code> ：光标跳到本单词的尾部。</p><p><code>x</code> ：每按一次，删除光标所在位置的一个字符。</p><p><code>nx</code> ：如”3x”表示删除光标所在位置开始的3个字符。</p><p><code>dw</code> ：删除光标所在位置到本单词结尾的字符。</p><p><code>D</code> ：删除本行光标所在位置后面全部的内容。</p><p><code>dd</code> ：删除光标所在位置的一行。</p><p><code>ndd</code> ：如”3dd”表示删除光标所在位置开始的3行。</p><p><code>yy</code> ：将光标所在位置的一行复制到缓冲区。</p><p><code>nyy</code> ：将光标所在位置的n行复制到缓冲区。</p><p><code>p</code> ：将缓冲区里的内容粘贴到光标所在位置。</p><p><code>r</code> ：替换光标所在位置的一个字符 replace。</p><p><code>R</code> ：从光标所在位置开始替换，直到按下”Esc”。</p><p><code>cw</code> ：从光标所在位置开始替换单词，直到按下”Esc”。</p><p><code>u</code> ：撤销命令，可多次撤销。</p><p><code>J</code> ：把当前行的下一行接到当前行的尾部。</p><p><code>/abcd</code> ：在当前打开的文件中查找“abcd”文本内容。</p><p><code>n</code> ：查找下一个。</p><p><code>N</code> ：查找上一下。</p><p><code>.</code> ：重复执行上一次执行的vi命令。</p><p><code>~</code> ：对光标当前所在的位置的字符进行大小写转换。</p><p><strong>列操作</strong></p><p><code>Ctrl+V</code> ：光标上或下  大写的I  输入内容  Esc</p><p><code>:w回车</code> ：存盘。</p><p><code>:w!回车</code> ：强制存盘。</p><p><code>:wq回车</code> ：存盘退出。</p><p><code>:x回车</code> ：存盘退出。</p><p><code>:q回车</code> ：不存盘退出。</p><p><code>:q!回车</code> ：不存盘强制退出。</p><p><code>:g/aaaaaaaaa/s//bbbbbb/g回车</code> ：把文件中全部的aaaaaaaaa替换成bbbbbb。</p><p><code>Ctl+insert</code> ：复制鼠标选中的文本，相当于Ctl+c。</p><p><code>Shift+insert</code> ：输出鼠标选中的文本，相当于Ctl+v。</p><p>以上两个命令在windows和UNIX中是通用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、关于vi&quot;&gt;&lt;a href=&quot;#一、关于vi&quot; class=&quot;headerlink&quot; title=&quot;一、关于vi&quot;&gt;&lt;/a&gt;一、关于vi&lt;/h1&gt;&lt;p&gt;vi是最强大的文本编辑器，没有之一。&lt;/p&gt;
&lt;p&gt;尽管vi已经是古董级的软件，但还是有无数新人迎着困难去学</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="常用工具" scheme="https://jinbilianshao.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vi" scheme="https://jinbilianshao.github.io/tags/vi/"/>
    
  </entry>
  
  <entry>
    <title>10.使用控制流</title>
    <link href="https://jinbilianshao.github.io/wiki/10-%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>https://jinbilianshao.github.io/wiki/10-%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
    <published>2023-03-02T11:27:00.000Z</published>
    <updated>2023-03-02T11:48:04.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="10-使用控制流"><a href="#10-使用控制流" class="headerlink" title="10.使用控制流"></a>10.使用控制流</h3><h4 id="使用控制流-（Linux-环境下正常）"><a href="#使用控制流-（Linux-环境下正常）" class="headerlink" title="使用控制流 （Linux 环境下正常）"></a>使用控制流 （Linux 环境下正常）</h4><hr><p>本章前面的示例中，已经使用过 if-else-endif 。</p><p>CMake还提供了创建循环的语言工具： foreach endforeach 和 while-endwhile 。两者都可以与 break 结合使用，以便尽早从循环中跳出。</p><p>本示例将展示如何使用 foreach ，来循环源文件列表。我们将应用这样的循环，在引入新目标的前提下，来为一组源文件进行优化降级。</p><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><hr><ol><li><p>声明最低要求的 CMake 版本，项目名称和语言，并声明了库目标</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(download LIANGUAGES CXX)</span><br><span class="line"><span class="keyword">add_library</span>(progressbar</span><br><span class="line">SHARED</span><br><span class="line">ProgressBar.h</span><br><span class="line">ProgressBar.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_library</span>(printer</span><br><span class="line">SHARED</span><br><span class="line">Printer.h</span><br><span class="line">Printer.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_library</span>(sleep</span><br><span class="line">SHARED</span><br><span class="line">Sleep.h</span><br><span class="line">Sleep.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>-O3</code>编译器优化级别编译库，对目标设置一个私有编译器选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(progressbar</span><br><span class="line">PRIVATE</span><br><span class="line">-O3</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_options</span>(Sleep</span><br><span class="line">PRIVATE</span><br><span class="line">-O3</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_options</span>(</span><br><span class="line">PRIVATE</span><br><span class="line">-O3</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>然后，生成一个源文件列表，以较低的优化选项进行编译</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND sources_list</span><br><span class="line">ProgressBar.h</span><br><span class="line">ProgressBar.cpp</span><br><span class="line">Sleep.h</span><br><span class="line">Sleep.cpp</span><br><span class="line">Printer.h</span><br><span class="line">Printer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>循环这些源文件，将它们的优化级别调到 -O2 。使用它们的源文件属性完成:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Setting source properties using IN LISTS syntax: &quot;</span>)</span><br><span class="line">   <span class="keyword">foreach</span>(_source IN LISTS sources_list)</span><br><span class="line">   <span class="keyword">set_source_files_properties</span>($(_source) PROPERTIES COMPILE_FLAGS -O2)</span><br><span class="line">   <span class="keyword">message</span>(STATUS <span class="string">&quot;##### Appending -O2 flag for $&#123;_source&#125;&quot;</span>)</span><br><span class="line">   <span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></li><li><p>为了确保设置属性，再次循环并在打印每个源文件的 COMPILE_FLAGS 属性</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(_source IN LISTS sources_list)</span><br><span class="line">get_source_files_property(_flags <span class="variable">$&#123;_source&#125;</span> COMPILE_FLAGS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></li><li><p>最后，添加 download 可执行目标，并将 progressbar、printer、sleep 库连接上去</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(download download.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(download progressbar printer sleep)</span><br></pre></td></tr></table></figure></li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr><p>foreach-endforeach 语法可用于在变量列表上，表示重复特定任务。</p><p>本示例中，使用它来操作、设置和获取项目中特定文件的编译器标志。CMake代码片段中引入了另外两个新命令:</p><ul><li><p>set_source_files_properties(file PROPERTIES property value) ，它将属性设置为给定文件的传递值。</p><p>与目标非常相似，文件在CMake中也有属性，允许对构建系统进行非常细粒度的控制。</p></li><li><p>get_source_file_property(VAR file property) ，检索给定文件所需属性的值，并将其存储在 CMake VAR 变量中。</p><hr></li><li><p>CMake中，列表是用分号分隔的字符串组。列表可以由 list 或 set 命令创建。</p><p>例如， set(var a b c d e) 和 list(APPEND a b c d e) 都创建了列表 a;b;c;d;e 。</p></li></ul><h4 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h4><p><a href="/wikicode/download/cmake/1.10.zip">使用控制流源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;10-使用控制流&quot;&gt;&lt;a href=&quot;#10-使用控制流&quot; class=&quot;headerlink&quot; title=&quot;10.使用控制流&quot;&gt;&lt;/a&gt;10.使用控制流&lt;/h3&gt;&lt;h4 id=&quot;使用控制流-（Linux-环境下正常）&quot;&gt;&lt;a href=&quot;#使用控制流-（Lin</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>9.为语言设定标准</title>
    <link href="https://jinbilianshao.github.io/wiki/9-%E4%B8%BA%E8%AF%AD%E8%A8%80%E8%AE%BE%E5%AE%9A%E6%A0%87%E5%87%86/"/>
    <id>https://jinbilianshao.github.io/wiki/9-%E4%B8%BA%E8%AF%AD%E8%A8%80%E8%AE%BE%E5%AE%9A%E6%A0%87%E5%87%86/</id>
    <published>2023-03-02T11:25:00.000Z</published>
    <updated>2023-03-02T11:26:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-为语言设定标准"><a href="#9-为语言设定标准" class="headerlink" title="9.为语言设定标准"></a>9.为语言设定标准</h3><h4 id="设置编译器选项"><a href="#设置编译器选项" class="headerlink" title="设置编译器选项"></a>设置编译器选项</h4><hr><p>编程语言有不同的标准，即提供改进的语言版本。启用新标准是通过设置适当的编译器标志来实现的。<br>前面的示例中，我们已经展示了如何为每个目标或全局进行配置。</p><p>3.1版本中，CMake引入了一个独立于平台和编译器的机制，用于为 C++ 和 C 设置语言标准：为目标设置 <LANG>_STANDARD 属性。</p><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><hr><ol><li><p>声明最低要求的 CMake 版本，项目名称和语言</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(download LIANGUAGES CXX)</span><br></pre></td></tr></table></figure></li><li><p>要求在 Windows 上导出所有库符号</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li><li><p>需要为库添加一个目标，这将编译源代码为一个动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(progressbar</span><br><span class="line">SHARED</span><br><span class="line">ProgressBar.h</span><br><span class="line">ProgressBar.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>现在，为目标设置了 CXX_STANDARD 、 CXX_EXTENSIONS 和 CXX_STANDARD_REQUIRED 属性。</p><p>还设置了 position_independent ent_code 属性，以避免在使用一些编译器构建 DSO 时出现问题</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(</span><br><span class="line">PROPERTIES</span><br><span class="line">CXX_STANDARD <span class="number">14</span></span><br><span class="line">CXX_EXTENSIONS <span class="keyword">OFF</span></span><br><span class="line">CXX_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>然后，为 download 的可执行文件添加一个新目标，并设置它的属性</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(download download.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(progressbar</span><br><span class="line">PROPERTIES</span><br><span class="line">CXX_STANDARD <span class="number">14</span></span><br><span class="line">CXX_EXTENSIONS <span class="keyword">OFF</span></span><br><span class="line">CXX_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>最后，将可执行文件链接到库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(download progressbar)</span><br></pre></td></tr></table></figure></li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li><p>CXX_STANDARD 会设置我们想要的标准。</p></li><li><p>CXX_EXTENSIONS 告诉 CMake，只启用 ISO C++ 标准的编译器标志，而不使用特定编译器的扩展。</p></li><li><p>CXX_STANDARD_REQUIRED 指定所选标准的版本。如果这个版本不可用，CMake将停止配置并出现错误。</p><p>当这个属性被设置为 OFF 时，CMake将寻找下一个标准的最新版本，直到一个合适的标志。</p><p>这意味着，首先查找 C++14 ，然后是 C++11 ，然后是 C++98 。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;9-为语言设定标准&quot;&gt;&lt;a href=&quot;#9-为语言设定标准&quot; class=&quot;headerlink&quot; title=&quot;9.为语言设定标准&quot;&gt;&lt;/a&gt;9.为语言设定标准&lt;/h3&gt;&lt;h4 id=&quot;设置编译器选项&quot;&gt;&lt;a href=&quot;#设置编译器选项&quot; class=&quot;he</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>8.设置编译器选项</title>
    <link href="https://jinbilianshao.github.io/wiki/8-%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9/"/>
    <id>https://jinbilianshao.github.io/wiki/8-%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9/</id>
    <published>2023-03-02T11:24:00.000Z</published>
    <updated>2023-03-02T11:25:07.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="8-设置编译器选项"><a href="#8-设置编译器选项" class="headerlink" title="8.设置编译器选项"></a>8.设置编译器选项</h3><h4 id="设置编译器选项"><a href="#设置编译器选项" class="headerlink" title="设置编译器选项"></a>设置编译器选项</h4><hr><p>前面的示例展示了如何探测 CMake，从而获得关于编译器的信息，以及如何切换项目中的编译器。后一个任务是控制项目的编译器标志。CMake为调整或扩展编译器标志提供了很大的灵活性，您可以选择下面两种方法:<br>        CMake 将编译选项视为目标属性。因此，可以根据每个目标设置编译选项，而不需要覆盖 CMake 默认值。<br>        可以使用 -D CLI 标志直接修改 CMAKE_<LANG>_FLAGS_<CONFIG> 变量。这将影响项目中的所有目标，并覆盖或扩展 CMake 默认值。</p><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><hr><ol><li><p>设置CMake的最低版本:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure></li><li><p>声明项目名称和语言</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(hello-cmake LANGUAGES CXX)</span><br></pre></td></tr></table></figure></li><li><p>然后，打印当前编译器标志。CMake将对所有C++目标使用这些</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C++ compiler flags is: $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>为目标准备了标志列表，其中一些将无法在Windows上使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND flags <span class="string">&quot;-fPIC&quot;</span> <span class="string">&quot;-Wall&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> WIN32)</span><br><span class="line"><span class="keyword">list</span>(APPEND flags <span class="string">&quot;-Wextra&quot;</span> <span class="string">&quot;-Wpedantic&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li><li><p>添加了一个新的目标—— message 库，并列出它的源依赖关系</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> </span><br><span class="line">STATIC</span><br><span class="line"><span class="keyword">Message</span>.h</span><br><span class="line"><span class="keyword">Message</span>.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>为这个库目标设置了编译选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(<span class="keyword">message</span></span><br><span class="line">PRIVATE</span><br><span class="line"><span class="variable">$&#123;flags&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>然后，将生成 hello-cmake 可执行文件作为一个目标</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-cmake hello-cmake.cpp)</span><br></pre></td></tr></table></figure></li><li><p>还为可执行目标设置了编译选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(hello-cmake</span><br><span class="line">PRIVATE</span><br><span class="line"><span class="string">&quot;-fPIC&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>最后，将可执行文件链接到 message 库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-cmake <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h4><hr><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本例中，警告标志有 -Wall 、 -Wextra 和 -Wpedantic ，将这些标示添加到 geometry 目标的编译选项中； compute-areas 和 geometry 目标都将使用 -fPIC 标志。</span></span><br><span class="line"><span class="comment"># 编译选项可以添加三个级别的可见性：INTERFACE、PUBLIC 和 PRIVATE 。</span></span><br><span class="line"><span class="comment"># 可见性的含义如下:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PRIVATE，编译选项会应用于给定的目标，不会传递给与目标相关的目标。</span></span><br><span class="line"><span class="comment"># 我们的示例中， 即使 compute-areas 将链接到 geometry 库， compute-areas 也不会继承 geometry 目标上设置的编译器选项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INTERFACE，给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PUBLIC，编译选项将应用于指定目标和使用它的目标。</span></span><br><span class="line"><span class="comment"># 目标属性的可见性 CMake 的核心，我们将在本书中经常讨论这个话题。</span></span><br><span class="line"><span class="comment"># 以这种方式添加编译选项，不会影响全局CMake变量 CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt; ，并能更细粒度控制在哪些目标上使用哪些选项。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;8-设置编译器选项&quot;&gt;&lt;a href=&quot;#8-设置编译器选项&quot; class=&quot;headerlink&quot; title=&quot;8.设置编译器选项&quot;&gt;&lt;/a&gt;8.设置编译器选项&lt;/h3&gt;&lt;h4 id=&quot;设置编译器选项&quot;&gt;&lt;a href=&quot;#设置编译器选项&quot; class=&quot;he</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>7.切换构建类型</title>
    <link href="https://jinbilianshao.github.io/wiki/7-%E5%88%87%E6%8D%A2%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jinbilianshao.github.io/wiki/7-%E5%88%87%E6%8D%A2%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-03-02T11:21:00.000Z</published>
    <updated>2023-03-02T11:23:12.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="7-切换构建类型"><a href="#7-切换构建类型" class="headerlink" title="7.切换构建类型"></a>7.切换构建类型</h3><h4 id="切换构建类型"><a href="#切换构建类型" class="headerlink" title="切换构建类型"></a>切换构建类型</h4><hr><blockquote><p>CMake可以配置构建类型，例如：Debug、Release等。配置时，可以为Debug或Release构建设置相关的选项或属性，<br>例如：编译器和链接器标志。控制生成构建系统使用的配置变量是CMAKE_BUILD_TYPE。该变量默认为空，CMake识别的值为:<br>Debug：               用于在没有优化的情况下，使用带有调试符号构建库或可执行文件。<br>Release：             用于构建的优化的库或可执行文件，不包含调试符号。<br>RelWithDebInfo：用于构建较少的优化库或可执行文件，包含调试符号。<br>MinSizeRel：      用于不增加目标代码大小的优化方式，来构建库或可执行文件。</p></blockquote><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><hr><ol><li>首先，定义最低CMake版本、项目名称和支持的语言：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(hello-world LANGUAGES CXX)</span><br></pre></td></tr></table></figure><ol start="2"><li>然后，设置一个默认的构建类型(本例中是 Release )，并打印一条消息。要注意的是，该变量被设置为缓存变量，可以通过缓存进行编辑：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Build type is: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>打印出CMake设置的相应编译标志：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, Debug: $&#123;CMAKE_C_FLAGES_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, Release: $&#123;CMAKE_C_FLAGES_RELEASE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, Release: $&#123;CMAKE_C_FLAGS_RELWITHDEBINFO&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, minimal: $&#123;CMAKE_C_FLAGS_MINISIZEREL&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Debug:$&#123;CMAKE_CXX_FLAGS_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Release:$&#123;CMAKE_CXX_FLAGS_RELEASE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Release:$&#123;CMAKE_CXX_FELWITHDEBINFO&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Minimal:$&#123;CMAKE_CXX_FLAGS_MINISIZEREL&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>验证配置输出</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"></span><br><span class="line">-- The CXX compiler identification is GNU 10.2.0</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++.exe - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- ##### Build type is:                                        Release</span><br><span class="line">-- ##### C flags, Debug configuration:</span><br><span class="line">-- ##### C flags, Release configuration:</span><br><span class="line">-- ##### C flags, Release configuration with Debug info:</span><br><span class="line">-- ##### C flags, minimal Release configuration:</span><br><span class="line">-- ##### C++ flags, Debug configuration:                       -g</span><br><span class="line">-- ##### C++ flags, Release configuration:                     -O3 -DNDEBUG</span><br><span class="line">-- ##### C++ flags, Release configuration with Debug info:     -O2 -g -DNDEBUG</span><br><span class="line">-- ##### C++ flags, minimal Release configuration:             -Os -DNDEBUG</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /d/Databases/Desktop/cmake/build</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line"></span><br><span class="line">[ 33%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line">[ 66%] Building CXX object CMakeFiles/hello-world.dir/Message.cpp.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking CXX executable hello-world.exe</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target hello-world</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line"></span><br><span class="line">CMakeCache.txt  CMakeFiles  Makefile  cmake_install.cmake  hello-world.exe</span><br></pre></td></tr></table></figure><ol start="5"><li>切换构建类型</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -D CMAKE_BUILD_TYPE=Debug ..</span></span><br><span class="line"></span><br><span class="line">-- The CXX compiler identification is GNU 10.2.0</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++.exe - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- ##### Build type is:                                        Debug</span><br><span class="line">-- ##### C flags, Debug configuration:</span><br><span class="line">-- ##### C flags, Release configuration:</span><br><span class="line">-- ##### C flags, Release configuration with Debug info:</span><br><span class="line">-- ##### C flags, minimal Release configuration:</span><br><span class="line">-- ##### C++ flags, Debug configuration:                       -g</span><br><span class="line">-- ##### C++ flags, Release configuration:                     -O3 -DNDEBUG</span><br><span class="line">-- ##### C++ flags, Release configuration with Debug info:     -O2 -g -DNDEBUG</span><br><span class="line">-- ##### C++ flags, minimal Release configuration:             -Os -DNDEBUG</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /d/Databases/Desktop/cmake/build</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line"></span><br><span class="line">[ 33%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line">[ 66%] Building CXX object CMakeFiles/hello-world.dir/Message.cpp.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking CXX executable hello-world.exe</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target hello-world</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line"></span><br><span class="line">CMakeCache.txt  CMakeFiles  Makefile  cmake_install.cmake  hello-world.exe</span><br></pre></td></tr></table></figure><ol start="6"><li>多参数构建</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时构建 Release 和 静态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -D CMAKE_BUILD_TYPE=Release -D USE_LIBRARY=ON ..</span></span><br><span class="line"></span><br><span class="line">-- The CXX compiler identification is GNU 10.2.0</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++.exe - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- ##### Build type is:                                        Release</span><br><span class="line">-- ##### C flags, Debug configuration:</span><br><span class="line">-- ##### C flags, Release configuration:</span><br><span class="line">-- ##### C flags, Release configuration with Debug info:</span><br><span class="line">-- ##### C flags, minimal Release configuration:</span><br><span class="line">-- ##### C++ flags, Debug configuration:                       -g</span><br><span class="line">-- ##### C++ flags, Release configuration:                     -O3 -DNDEBUG</span><br><span class="line">-- ##### C++ flags, Release configuration with Debug info:     -O2 -g -DNDEBUG</span><br><span class="line">-- ##### C++ flags, minimal Release configuration:             -Os -DNDEBUG</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /d/Databases/Desktop/cmake/build</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line"></span><br><span class="line">[ 25%] Building CXX object CMakeFiles/message.dir/Message.cpp.o</span><br><span class="line">[ 50%] Linking CXX static library libmessage.a</span><br><span class="line">[ 50%] Built target message</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking CXX executable hello-world.exe</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target hello-world</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译出 libmessage.a</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line"></span><br><span class="line">CMakeCache.txt  CMakeFiles  Makefile  cmake_install.cmake  hello-world.exe  libmessage.a</span><br></pre></td></tr></table></figure><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr><p>我们演示了如何设置默认构建类型，以及如何(从命令行)覆盖它。这样，就可以控制项目，是使用优化，还是关闭优化启用调试。</p><p>我们还看到了不同配置使用了哪些标志，这主要取决于选择的编译器。</p><p>需要在运行CMake时显式地打印标志，也可以仔细阅读运行<code>CMake --system-information</code>的输出，以了解当前平台、默认编译器和语言的默认组合是什么。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello-cmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(USE_LIBRARY <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND _sources <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Build type is:                                    $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, Debug configuration:                     $&#123;CMAKE_C_FLAGS_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, Release configuration:                   $&#123;CMAKE_C_FLAGS_RELEASE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, Release configuration with Debug info:   $&#123;CMAKE_C_FLAGS_RELWITHDEBINFO&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C flags, minimal Release configuration:           $&#123;CMAKE_C_FLAGS_MINSIZEREL&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Debug configuration:                   $&#123;CMAKE_CXX_FLAGS_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Release configuration:                 $&#123;CMAKE_CXX_FLAGS_RELEASE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, Release configuration with Debug info: $&#123;CMAKE_CXX_FLAGS_RELWITHDEBINFO&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### C++ flags, minimal Release configuration:         $&#123;CMAKE_CXX_FLAGS_MINSIZEREL&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (USE_LIBRARY)</span><br><span class="line">    <span class="keyword">add_library</span>(<span class="keyword">message</span> <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line">    <span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_executable</span>(hello-world hello-world.cpp <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;7-切换构建类型&quot;&gt;&lt;a href=&quot;#7-切换构建类型&quot; class=&quot;headerlink&quot; title=&quot;7.切换构建类型&quot;&gt;&lt;/a&gt;7.切换构建类型&lt;/h3&gt;&lt;h4 id=&quot;切换构建类型&quot;&gt;&lt;a href=&quot;#切换构建类型&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>6.指定编译器</title>
    <link href="https://jinbilianshao.github.io/wiki/6-%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>https://jinbilianshao.github.io/wiki/6-%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E5%99%A8/</id>
    <published>2023-03-02T11:13:00.000Z</published>
    <updated>2023-03-02T11:20:12.953Z</updated>
    
    <content type="html"><![CDATA[<h4 id="指定编译器"><a href="#指定编译器" class="headerlink" title="指定编译器"></a>指定编译器</h4><hr><blockquote><p>目前为止，我常用的编译器都集中在交叉编译，例如arm，arm64等。</p><p>CMake可以根据平台和生成器选择编译器，还能将编译器标志设置为默认值。</p><p>然而，我们通常控制编译器的选择。</p><p>在后面的示例中，我们还将考虑构建类型的选择，并展示如何控制编译器标志。</p></blockquote><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><hr><blockquote><p>CMake将语言的编译器存储在 CMAKE_<LANG>_COMPILER 变量中，其中 <LANG> 是受支持的任何一种语言，</p><p>对于我们的目的是 CXX 、 C 或 Fortran 。用户可以通过以下两种方式之一设置此变量：</p></blockquote><ol><li>``` cmake<h1 id="使用CLI中的-D-选项，例如："><a href="#使用CLI中的-D-选项，例如：" class="headerlink" title="使用CLI中的 -D 选项，例如："></a>使用CLI中的 -D 选项，例如：</h1>cmake -D CMAKE_CXX_COMPILER=clang++ ..<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` cmake</span><br><span class="line">   # 通过导出环境变量 CXX (C++编译器)、 CC (C编译器)和 FC (Fortran编译器)。</span><br><span class="line">   # 例如，使用这个命令使用 clang++ 作为 C++ 编译器：</span><br><span class="line">   env CXX=clang++ cmake ..</span><br></pre></td></tr></table></figure></li></ol><h4 id="编译器选项"><a href="#编译器选项" class="headerlink" title="编译器选项"></a>编译器选项</h4><ul><li>CMAKE_CXX_COMPILER </li><li>CMAKE_C_COMPILER </li><li>CMAKE_Fortran_COMPILER</li></ul><h5 id="实例运行输出结果"><a href="#实例运行输出结果" class="headerlink" title="实例运行输出结果"></a>实例运行输出结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"></span><br><span class="line">-- Building for: Visual Studio 16 2019</span><br><span class="line">-- Selecting Windows SDK version 10.0.19041.0 to target Windows 10.0.19042.</span><br><span class="line">-- The C compiler identification is MSVC 19.29.30038.1</span><br><span class="line">-- The CXX compiler identification is MSVC 19.29.30038.1</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe - skipped</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- ##### Is the C++ compiler loaded? 1 #####</span><br><span class="line">-- ##### The C++ compiler ID is: MSVC #####</span><br><span class="line">-- ##### Is the C++ from GNU?  #####</span><br><span class="line">-- ##### The C++ compiler version is: 19.29.30038.1 #####</span><br><span class="line">-- ##### Is the C compiler loaded? 1 #####</span><br><span class="line">-- ##### The C compiler ID is: MSVC #####</span><br><span class="line">-- ##### Is the C++ from GNU?  #####</span><br><span class="line">-- ##### The C compiler version is: 19.29.30038.1 #####</span><br><span class="line">-- Configuring done</span><br></pre></td></tr></table></figure><h4 id="CMakeLists-txt文件"><a href="#CMakeLists-txt文件" class="headerlink" title="CMakeLists.txt文件"></a>CMakeLists.txt文件</h4><p>在CMakeLists.txt文件中通常如下指定，不用是注释掉，用的时候取消注释。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[#FT</span></span><br><span class="line"><span class="comment">set(CMAKE_SYSTEM_NAME Linux)</span></span><br><span class="line"><span class="comment">set(CMAKE_C_COMPILER &quot;/bin/aarch64-linux-gnu-gcc&quot;)</span></span><br><span class="line"><span class="comment">set(CMAKE_CXX_COMPILER &quot;/bin/aarch64-linux-gnu-g++&quot;)]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[#7045</span></span><br><span class="line"><span class="comment">set(CMAKE_SYSTEM_NAME Linux)</span></span><br><span class="line"><span class="comment">set(CMAKE_C_COMPILER &quot;/bin/arm-linux-gnueabihf-gcc&quot;)</span></span><br><span class="line"><span class="comment">set(CMAKE_CXX_COMPILER &quot;/bin/arm-linux-gnueabihf-g++&quot;)]]</span></span><br></pre></td></tr></table></figure><p>例子1：CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，这个例子不包含任何目标，没有要构建的东西，我们只关注配置步骤:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello-world LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Is the C++ compiler loaded? $&#123;CMAKE_CXX_COMPILER_LOADED&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$&#123;CMAKE_CXX_COMPILER_LOADED&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### The C++ compiler ID is: $&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Is the C++ from GNU? $&#123;CMAKE_COMPILER_IS_GNUCXX&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### The C++ compiler version is: $&#123;CMAKE_CXX_COMPILER_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Is the C compiler loaded? $&#123;CMAKE_C_COMPILER_LOADED&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$&#123;CMAKE_C_COMPILER_LOADED&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### The C compiler ID is: $&#123;CMAKE_C_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### Is the C++ from GNU? $&#123;CMAKE_COMPILER_IS_GNUCC&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### The C compiler version is: $&#123;CMAKE_C_COMPILER_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>例子2：CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello-world LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(CMAKE_CXX_COMPILER clang++)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### 编译器：$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### 编译器版本：$&#123;CMAKE_CXX_COMPILER_VERSION&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(USE_LIBRARY <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;##### USE_LIBRARY? $&#123;USE_LIBRARY&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND _sources <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$&#123;USE_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp <span class="keyword">message</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;指定编译器&quot;&gt;&lt;a href=&quot;#指定编译器&quot; class=&quot;headerlink&quot; title=&quot;指定编译器&quot;&gt;&lt;/a&gt;指定编译器&lt;/h4&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;目前为止，我常用的编译器都集中在交叉编译，例如arm，arm64等。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>5.向用户显示选项</title>
    <link href="https://jinbilianshao.github.io/wiki/5-%E5%90%91%E7%94%A8%E6%88%B7%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9/"/>
    <id>https://jinbilianshao.github.io/wiki/5-%E5%90%91%E7%94%A8%E6%88%B7%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9/</id>
    <published>2023-03-02T11:10:00.000Z</published>
    <updated>2023-03-02T11:12:34.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-向用户显示选项"><a href="#5-向用户显示选项" class="headerlink" title="5.向用户显示选项"></a>5.向用户显示选项</h3><h4 id="向用户显示选项"><a href="#向用户显示选项" class="headerlink" title="向用户显示选项"></a>向用户显示选项</h4><blockquote><p>前面的配置中，我们引入了条件句：通过硬编码的方式给定逻辑变量值。不过，这会影响用户修改这些变量。</p><p>CMake代码没有向读者传达，该值可以从外部进行修改。推荐在 CMakeLists.txt 中使用 option() 命令，</p><p>以选项的形式显示逻辑开关，用于外部设置，从而切换构建系统的生成行为。</p><p>本节的示例将向您展示，如何使用这个命令。</p></blockquote><hr><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><ol><li>``` cmake<h1 id="用一个选项替换上一个示例的-set-USE-LIBRARY-OFF-命令。该选项将修改-USE-LIBRARY-的值，并设置其默认值为-OFF-："><a href="#用一个选项替换上一个示例的-set-USE-LIBRARY-OFF-命令。该选项将修改-USE-LIBRARY-的值，并设置其默认值为-OFF-：" class="headerlink" title="用一个选项替换上一个示例的 set(USE_LIBRARY OFF) 命令。该选项将修改 USE_LIBRARY 的值，并设置其默认值为 OFF ："></a>用一个选项替换上一个示例的 set(USE_LIBRARY OFF) 命令。该选项将修改 USE_LIBRARY 的值，并设置其默认值为 OFF ：</h1>option(USE_LIBRARY “Compile sources into a library” OFF)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` shell</span><br><span class="line">   # 现在，可以通过CMake的 -D CLI 选项，将信息传递给 CMake 来切换库的行为：</span><br><span class="line">   # -D 开关用于为 CMake 设置任何类型的变量：逻辑变量、路径等等。</span><br><span class="line">   $ mkdir build</span><br><span class="line">   $ cd build</span><br><span class="line">   $ cmake -D USE_LIBRARY=ON ..</span><br><span class="line">   $</span><br><span class="line">   $ cmake --build .</span><br></pre></td></tr></table></figure></li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr><blockquote><p>option 可接受三个参数：<br>option(<option_variable> “help string” [initial value])</p><p>​    <option_variable> 表示该选项的变量的名称。<br>​    “help string” 记录选项的字符串，在CMake的终端或图形用户界面中可见。<br>​    [initial value] 选项的默认值，可以是 ON 或 OFF 。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;5-向用户显示选项&quot;&gt;&lt;a href=&quot;#5-向用户显示选项&quot; class=&quot;headerlink&quot; title=&quot;5.向用户显示选项&quot;&gt;&lt;/a&gt;5.向用户显示选项&lt;/h3&gt;&lt;h4 id=&quot;向用户显示选项&quot;&gt;&lt;a href=&quot;#向用户显示选项&quot; class=&quot;he</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>4.用条件句控制编译</title>
    <link href="https://jinbilianshao.github.io/wiki/4-%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%A5%E6%8E%A7%E5%88%B6%E7%BC%96%E8%AF%91/"/>
    <id>https://jinbilianshao.github.io/wiki/4-%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%A5%E6%8E%A7%E5%88%B6%E7%BC%96%E8%AF%91/</id>
    <published>2023-03-02T11:08:00.000Z</published>
    <updated>2023-03-02T11:09:55.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-用条件句控制编译"><a href="#4-用条件句控制编译" class="headerlink" title="4.用条件句控制编译"></a>4.用条件句控制编译</h3><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><hr><ol><li>将 Message.hpp 和 Message.cpp 构建成一个库(静态或动态)，然后将生成库链接到 hello-<br>world 可执行文件中。</li><li>将 Message.hpp ， Message.cpp 和 hello-world.cpp 构建成一个可执行文件，但不生成任<br>何一个库。</li></ol><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><hr><ol><li><p>```cmake</p><h1 id="首先，定义最低CMake版本、项目名称和支持的语言："><a href="#首先，定义最低CMake版本、项目名称和支持的语言：" class="headerlink" title="首先，定义最低CMake版本、项目名称和支持的语言："></a>首先，定义最低CMake版本、项目名称和支持的语言：</h1><p>cmake_minimum_required(VERSION 3.5)</p><p>project(hello-world LANGUAGES CXX)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` cmake</span><br><span class="line">   # 我们引入了一个新变量 USE_LIBRARY ，这是一个逻辑变量，值为 OFF 。我们还打印了它的值：</span><br><span class="line">   set(USE_LIBRARY OFF)</span><br><span class="line">   message(STATUS &quot;Compile sources into a library? $&#123;USE_LIBRARY&#125;&quot;)</span><br></pre></td></tr></table></figure></li><li><p>``` cmake</p><h1 id="CMake中定义-BUILD-SHARED-LIBS-全局变量，并设置为-OFF-。调用-add-library-并省略第二个参数，将构建一个静态库"><a href="#CMake中定义-BUILD-SHARED-LIBS-全局变量，并设置为-OFF-。调用-add-library-并省略第二个参数，将构建一个静态库" class="headerlink" title="CMake中定义 BUILD_SHARED_LIBS 全局变量，并设置为 OFF 。调用 add_library 并省略第二个参数，将构建一个静态库"></a>CMake中定义 BUILD_SHARED_LIBS 全局变量，并设置为 OFF 。调用 add_library 并省略第二个参数，将构建一个静态库</h1><p>set(BUILD_SHARED_LIBS OFF)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ``` cmake</span><br><span class="line">   # 然后，引入一个变量 _sources，包含所有源文件和头文件：</span><br><span class="line">   list(APPEND _sources Message.h Message.cpp)</span><br></pre></td></tr></table></figure></li><li><pre><code class="cmake"># 然后，引入一个基于 USE_LIBRARY 值的 if-else 语句。如果逻辑为真，则 Message.hpp 和 Message.cpp 将打包成一个库：if (USE_LIBRARY)    add_library(message $&#123;_source&#125;)    add_executable(hello-world hello-world.cpp)    target_link_libraries(hello-world message)else()    add_executable(hello-world hello-world.cpp $&#123;_sources&#125;)endif()</code></pre></li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr><blockquote><p>我们介绍了两个变量： USE_LIBRARY 和 BUILD_SHARED_LIBS 。这两个变量都设置为 OFF 。</p><p>如CMake语言文档中描述，逻辑真或假可以用多种方式表示：<br>如果将逻辑变量设置为以下任意一种： 1 、 ON 、 YES 、 true 、 Y 或非零数，则逻辑变量为 true 。<br>如果将逻辑变量设置为以下任意一种： 0 、 OFF 、 NO 、 false 、 N 、 IGNORE、<br>NOTFOUND 、空字符串，或者以 -NOTFOUND 为后缀，则逻辑变量为 false 。<br>USE_LIBRARY 变量将在第一个和第二个行为之间切换。 BUILD_SHARED_LIBS 是CMake的一个全局标志。因为CMake内部要查询 BUILD_SHARED_LIBS 全局变量，所以 add_library 命令可以在不传递 STATIC/SHARED/OBJECT 参数的情况下调用；如果为 false 或未定义，将生成一个静态库。</p><p>这个例子说明，可以引入条件来控制CMake中的执行流。但是，当前的设置不允许从外部切换，不需要<br>手动修改 CMakeLists.txt 。原则上，我们希望能够向用户开放所有设置，这样就可以在不修改构建<br>代码的情况下调整配置，稍后将展示如何做到这一点。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;4-用条件句控制编译&quot;&gt;&lt;a href=&quot;#4-用条件句控制编译&quot; class=&quot;headerlink&quot; title=&quot;4.用条件句控制编译&quot;&gt;&lt;/a&gt;4.用条件句控制编译&lt;/h3&gt;&lt;h4 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;head</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>3.构建和链接静态库和动态库</title>
    <link href="https://jinbilianshao.github.io/wiki/3-%E6%9E%84%E5%BB%BA%E5%92%8C%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://jinbilianshao.github.io/wiki/3-%E6%9E%84%E5%BB%BA%E5%92%8C%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</id>
    <published>2023-03-02T11:02:00.000Z</published>
    <updated>2023-03-02T11:04:48.538Z</updated>
    
    <content type="html"><![CDATA[<h4 id="3-构建和链接静态库和动态库"><a href="#3-构建和链接静态库和动态库" class="headerlink" title="3. 构建和链接静态库和动态库"></a>3. 构建和链接静态库和动态库</h4><hr><blockquote><p>项目中会有单个源文件构建的多个可执行文件的可能。项目中有多个源文件，通常分布在不同子目录<br>中。这种实践有助于项目的源代码结构，而且支持模块化、代码重用和关注点分离。同时，这种分离可<br>以简化并加速项目的重新编译。本示例中，我们将展示如何将源代码编译到库中，以及如何链接这些<br>库。</p></blockquote><h4 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h4><hr><ol><li>创建目标——静态库。库的名称和源码文件名相同，具体代码如下：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_libraries(<span class="keyword">message</span></span><br><span class="line">STATIC</span><br><span class="line"><span class="keyword">Message</span>.h</span><br><span class="line"><span class="keyword">Message</span>.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建 hello-world 可执行文件的目标部分不需要修改：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure></li><li><p>最后，将目标库链接到可执行目标：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-world messgae)</span><br></pre></td></tr></table></figure></li></ol><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line"></span><br><span class="line">[ 50%] Built target message</span><br><span class="line">Scanning dependencies of target hello-world</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking CXX executable hello-world</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target hello-world</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span><span class="comment"># 可以看到生成了 libmessage.a 静态库和可执行文件 hello-world</span></span></span><br><span class="line">CMakeCache.txt  CMakeFiles  cmake_install.cmake  hello-world  libmessage.a  Makefile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello-world</span></span><br><span class="line">This is my very nice message:</span><br><span class="line">hello, CMake World!</span><br><span class="line">This is my very nice message:</span><br><span class="line">Goodbye, CMake World!</span><br></pre></td></tr></table></figure><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr><p>**add_library(message STATIC Message.h Message.cpp) **：生成必要的构建指令，将指定<br>的源码编译到库中。 </p><p>add_library 的第<strong>一个参数是目标名</strong>。整个 CMakeLists.txt 中，可使用相同的名称来引用库。</p><p>生成的库的实际名称将由 CMake 通过在前面添加前缀 lib 和适当的扩展名作为后缀来形成。</p><p>生成库是根据第二个参数( <strong>STATIC 或 SHARED</strong> )和操作系统确定的。</p><hr><p>**target_link_libraries(hello-world message) **: 将库链接到可执行文件。</p><p>此命令还确保 hello-world 可执行文件可以正确地依赖于消息库。</p><p>因此，在消息库链接到 hello-world 可执行文件之前，需要完成消息库的构建。</p><p>编译成功后，构建目录包含 libmessage.a 一个静态库(在GNU/Linux上)和 hello-world 可执行文件。</p><h4 id="add-library-其他参数"><a href="#add-library-其他参数" class="headerlink" title="add_library 其他参数"></a>add_library 其他参数</h4><hr><ul><li><strong>STATIC</strong>：用于创建<strong>静态库</strong>，即编译文件的打包存档，以便在链接其他目标时使用，例如：可执行文件。</li><li><strong>SHARED</strong>：用于创建<strong>动态库</strong>，即可以动态链接，并在运行时加载的库。可以在 CMakeLists.txt 中使用 add_library(message SHARED Message.h Message.cpp) 从静态库切换到动态共享对象(DSO)。</li><li><strong>OBJECT</strong>：可将给定 add_library 的列表中的源码编译到目标文件，不将它们归档到静态库中，也不能将它们链接到共享对象中。如果需要<strong>一次性创建静态库和动态库</strong>，那么使用对象库尤其有用。</li><li><strong>MODULE</strong>：又为 DSO 组。与 SHARED 库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建<strong>运行时插件</strong>。</li></ul><h4 id="CMake-源代码"><a href="#CMake-源代码" class="headerlink" title="CMake 源代码"></a>CMake 源代码</h4><hr><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello-world LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目标——静态库。库的名称和源码文件名相同，具体代码如下：</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line">STATIC</span><br><span class="line"><span class="comment"># 包含库文件</span></span><br><span class="line"><span class="keyword">Message</span>.h</span><br><span class="line"><span class="keyword">Message</span>.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接目标库到可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;3-构建和链接静态库和动态库&quot;&gt;&lt;a href=&quot;#3-构建和链接静态库和动态库&quot; class=&quot;headerlink&quot; title=&quot;3. 构建和链接静态库和动态库&quot;&gt;&lt;/a&gt;3. 构建和链接静态库和动态库&lt;/h4&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;项目</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>2.切换生成器</title>
    <link href="https://jinbilianshao.github.io/wiki/2-%E5%88%87%E6%8D%A2%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://jinbilianshao.github.io/wiki/2-%E5%88%87%E6%8D%A2%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2023-03-02T10:52:00.000Z</published>
    <updated>2023-03-02T11:00:01.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-切换生成器"><a href="#2-切换生成器" class="headerlink" title="2.切换生成器"></a>2.切换生成器</h3><h4 id="显示构建器-（cmake-–help）"><a href="#显示构建器-（cmake-–help）" class="headerlink" title="显示构建器 （cmake –help）"></a>显示构建器 （cmake –help）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --<span class="built_in">help</span></span><br><span class="line">...</span><br><span class="line">Generators</span><br><span class="line"></span><br><span class="line">The following generators are available on this platform (* marks default):</span><br><span class="line">* Visual Studio 16 2019        = Generates Visual Studio 2019 project files.</span><br><span class="line">                                 Use -A option to specify architecture.</span><br><span class="line">  Visual Studio 15 2017 [<span class="built_in">arch</span>] = Generates Visual Studio 2017 project files.</span><br><span class="line">                                 Optional [<span class="built_in">arch</span>] can be <span class="string">&quot;Win64&quot;</span> or <span class="string">&quot;ARM&quot;</span>.</span><br><span class="line">  Visual Studio 14 2015 [<span class="built_in">arch</span>] = Generates Visual Studio 2015 project files.</span><br><span class="line">                                 Optional [<span class="built_in">arch</span>] can be <span class="string">&quot;Win64&quot;</span> or <span class="string">&quot;ARM&quot;</span>.</span><br><span class="line">  Visual Studio 12 2013 [<span class="built_in">arch</span>] = Generates Visual Studio 2013 project files.</span><br><span class="line">                                 Optional [<span class="built_in">arch</span>] can be <span class="string">&quot;Win64&quot;</span> or <span class="string">&quot;ARM&quot;</span>.</span><br><span class="line">  Visual Studio 11 2012 [<span class="built_in">arch</span>] = Generates Visual Studio 2012 project files.</span><br><span class="line">                                 Optional [<span class="built_in">arch</span>] can be <span class="string">&quot;Win64&quot;</span> or <span class="string">&quot;ARM&quot;</span>.</span><br><span class="line">  Visual Studio 10 2010 [<span class="built_in">arch</span>] = Generates Visual Studio 2010 project files.</span><br><span class="line">                                 Optional [<span class="built_in">arch</span>] can be <span class="string">&quot;Win64&quot;</span> or <span class="string">&quot;IA64&quot;</span>.</span><br><span class="line">  Visual Studio 9 2008 [<span class="built_in">arch</span>]  = Generates Visual Studio 2008 project files.</span><br><span class="line">                                 Optional [<span class="built_in">arch</span>] can be <span class="string">&quot;Win64&quot;</span> or <span class="string">&quot;IA64&quot;</span>.</span><br><span class="line">  Borland Makefiles            = Generates Borland makefiles.</span><br><span class="line">  NMake Makefiles              = Generates NMake makefiles.</span><br><span class="line">  NMake Makefiles JOM          = Generates JOM makefiles.</span><br><span class="line">  MSYS Makefiles               = Generates MSYS makefiles.</span><br><span class="line">  MinGW Makefiles              = Generates a make file <span class="keyword">for</span> use with</span><br><span class="line">                                 mingw32-make.</span><br><span class="line">  Green Hills MULTI            = Generates Green Hills MULTI files</span><br><span class="line">                                 (experimental, work-in-progress).</span><br><span class="line">  Unix Makefiles               = Generates standard UNIX makefiles.</span><br><span class="line">  Ninja                        = Generates build.ninja files.</span><br><span class="line">  Ninja Multi-Config           = Generates build-&lt;Config&gt;.ninja files.</span><br><span class="line">  Watcom WMake                 = Generates Watcom WMake makefiles.</span><br><span class="line">  CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files.</span><br><span class="line">  CodeBlocks - NMake Makefiles = Generates CodeBlocks project files.</span><br><span class="line">  CodeBlocks - NMake Makefiles JOM</span><br><span class="line">                               = Generates CodeBlocks project files.</span><br><span class="line">  CodeBlocks - Ninja           = Generates CodeBlocks project files.</span><br><span class="line">  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.</span><br><span class="line">  CodeLite - MinGW Makefiles   = Generates CodeLite project files.</span><br><span class="line">  CodeLite - NMake Makefiles   = Generates CodeLite project files.</span><br><span class="line">  CodeLite - Ninja             = Generates CodeLite project files.</span><br><span class="line">  CodeLite - Unix Makefiles    = Generates CodeLite project files.</span><br><span class="line">  Eclipse CDT4 - NMake Makefiles</span><br><span class="line">                               = Generates Eclipse CDT 4.0 project files.</span><br><span class="line">  Eclipse CDT4 - MinGW Makefiles</span><br><span class="line">                               = Generates Eclipse CDT 4.0 project files.</span><br><span class="line">  Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.</span><br><span class="line">  Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.</span><br><span class="line">  Kate - MinGW Makefiles       = Generates Kate project files.</span><br><span class="line">  Kate - NMake Makefiles       = Generates Kate project files.</span><br><span class="line">  Kate - Ninja                 = Generates Kate project files.</span><br><span class="line">  Kate - Unix Makefiles        = Generates Kate project files.</span><br><span class="line">  Sublime Text 2 - MinGW Makefiles</span><br><span class="line">                               = Generates Sublime Text 2 project files.</span><br><span class="line">  Sublime Text 2 - NMake Makefiles</span><br><span class="line">                               = Generates Sublime Text 2 project files.</span><br><span class="line">  Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files.</span><br><span class="line">  Sublime Text 2 - Unix Makefiles</span><br><span class="line">                               = Generates Sublime Text 2 project files.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="具体实施（用-G-切换生成器）"><a href="#具体实施（用-G-切换生成器）" class="headerlink" title="具体实施（用 -G 切换生成器）"></a>具体实施（用 -G 切换生成器）</h4><ol><li><p>首先，使用以下步骤配置项目:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -G <span class="string">&quot;CodeBlocks - Unix Makefiles&quot;</span> ..</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h4><p>与前一个配置相比，每一步的输出没什么变化。每个生成器都有自己的文件集，所以编译步骤的输出和<br>构建目录的内容是不同的：<br>build.ninja 和 rules.ninja ：包含 Ninja 的所有的构建语句和构建规则。<br>CMakeCache.txt ：CMake 会在这个文件中进行缓存，与生成器无关。<br>CMakeFiles ：包含由 CMake 在配置期间生成的临时文件。<br>cmake_install.cmake ：CMake 脚本处理安装规则，并在安装时使用。<br>cmake –build . 将 ninja 命令封装在一个跨平台的接口中。</p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>C示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello-world.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">say_hello</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, CMake world!&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, say_hello());</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="comment"># 设置最低 cmake 版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.c)</span><br></pre></td></tr></table></figure><p>C++示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello-world.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello, CMake world!&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">say_hello</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="comment"># 设置最低 cmake 版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2-切换生成器&quot;&gt;&lt;a href=&quot;#2-切换生成器&quot; class=&quot;headerlink&quot; title=&quot;2.切换生成器&quot;&gt;&lt;/a&gt;2.切换生成器&lt;/h3&gt;&lt;h4 id=&quot;显示构建器-（cmake-–help）&quot;&gt;&lt;a href=&quot;#显示构建器-（cmake-–</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>1.将单个源文件编译为可执行文件</title>
    <link href="https://jinbilianshao.github.io/wiki/1-%E5%B0%86%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://jinbilianshao.github.io/wiki/1-%E5%B0%86%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</id>
    <published>2023-03-02T10:47:00.000Z</published>
    <updated>2023-03-02T11:00:19.157Z</updated>
    
    <content type="html"><![CDATA[<h4 id="生成构建器"><a href="#生成构建器" class="headerlink" title="生成构建器"></a>生成构建器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br></pre></td></tr></table></figure><blockquote><p> 这里，我们创建了一个目录 build (生成构建器的位置)，进入 build 目录，并通过指定 CMakeLists.txt 的位置(本例中位于父目录中)来调用 CMake。</p><p>CMake语言不区分大小写，但是参数区分大小写。</p><p>CMake中，C++是默认的编程语言。不过，我们还是建议使用LANGUAGES 选项在 project 命令中显式地声明项目的语言。</p></blockquote><p>可以使用以下命令行来实现相同的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -H. -Bbuild</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令是跨平台的，使用了-H 和-B 为 CLI 选项。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-H 表示当前目录中搜索根 CMakeLists.txt 文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-Bbuild 告诉 CMake 在一个名为 build 的目录中生成所有的文件。</span></span><br></pre></td></tr></table></figure><h4 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 build 文件夹下执行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Windows 输出如下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line">用于 .NET Framework 的 Microsoft (R) 生成引擎版本 16.10.2+857e5a733</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">  Checking Build System</span><br><span class="line">  Building Custom Rule C:/Users/3D Objects/HelloCMake/CMakeLists.txt</span><br><span class="line">  HelloCMake.cpp</span><br><span class="line">  hello-cmake.vcxproj -&gt; C:\Users\3D Objects\HelloCMake\build\Debug\hello-cmake.exe</span><br><span class="line">  Building Custom Rule C:/Users/3D Objects/HelloCMake/CMakeLists.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;生成构建器&quot;&gt;&lt;a href=&quot;#生成构建器&quot; class=&quot;headerlink&quot; title=&quot;生成构建器&quot;&gt;&lt;/a&gt;生成构建器&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/categories/cmake/"/>
    
    <category term="第一章：从简单的可执行文件到库" scheme="https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"/>
    
    
    <category term="cmake" scheme="https://jinbilianshao.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>8.重写项目历史</title>
    <link href="https://jinbilianshao.github.io/wiki/8-%E9%87%8D%E5%86%99%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2/"/>
    <id>https://jinbilianshao.github.io/wiki/8-%E9%87%8D%E5%86%99%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2/</id>
    <published>2023-03-01T15:03:00.000Z</published>
    <updated>2023-03-01T15:06:52.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重写项目历史"><a href="#重写项目历史" class="headerlink" title="重写项目历史"></a>重写项目历史</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Git 的主要职责是保证你不会丢失提交的修改。但是，它同样被设计成让你完全掌控开发工作流。这包括了让你自定义你的项目历史，而这也创造了丢失提交的可能性。Git 提供了可以重写项目历史的命令，但也警告你这些命令可能会让你丢失内容。</p><p>这份教程讨论了重写提交快照的一些常见原因，并告诉你如何避免不好的影响。</p><h2 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h2><p><code>git commit --amend</code> 命令是修复最新提交的便捷方式。它允许你将缓存的修改和之前的提交合并到一起，而不是提交一个全新的快照。它还可以用来简单地编辑上一次提交的信息而不改变快照。</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:a4de784b-3572-4d23-8c68-cea9ad4f205f/01.svg" alt="Git Tutorial: git commit --amend"></p><p>但是，amend 不只是修改了最新的提交——它进行了一次替换。对于 Git 来说，这看上去像一个全新的提交，即上图中用星号表示的那一个。在公共仓库工作时一定要牢记这一点。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>合并缓存的修改和上一次的提交，用新的快照替换上一个提交。缓存区没有文件时运行这个命令可以用来编辑上次提交的提交信息，而不会更改快照。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>仓促的提交在你日常开发过程中时常会发生。很容易就忘记了缓存一个文件或者弄错了提交信息的格式。<code>--amend</code> 标记是修复这些小意外的便捷方式。</p><h4 id="不要修复公共提交"><a href="#不要修复公共提交" class="headerlink" title="不要修复公共提交"></a>不要修复公共提交</h4><p>在<a href="https://jinbilianshao.github.io/wikicode/wiki/7-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9/"><code>git reset</code></a>这节中，我们说过永远不要重设和其他开发者共享的提交。对于修复也是一样：永远不要修复一个已经推送到公共仓库中的提交。</p><p>修复过的提交事实上是全新的提交，之前的提交会被移除出项目历史。这和重设公共快照的后果是一样的。如果你修复了其他开发者在之后继续开发的一个提交，看上去他们的工作基础从项目历史中消失了一样。对于在这上面的开发者来说这是很困惑的，而且很难恢复。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个🌰展示了 Git 开发工作流中的一个常见情形。我们编辑了一些希望在同一个快照中提交的文件，但我们忘记添加了其中的一个。修复错误只需要缓存那个文件并且用 <code>--amend</code> 标记提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 编辑 hello.py 和 main.py</span><br><span class="line">git add hello.py</span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"># 意识到你忘记添加 main.py 的更改</span><br><span class="line">git add main.py</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p>编辑器会弹出上一次提交的信息，加入 <code>--no-edit</code> 标记会修复提交但不修改提交信息。需要的话你可以修改，不然的话就像往常一样保存并关闭文件。完整的提交会替换之前不完整的提交，看上去就像我们在同一个快照中提交了 <code>hello.py</code> 和 <code>main.py</code>。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>变基（rebase, 事实上这个名字十分诡异, 所以在大多数时候直接用英文术语）是将分支移到一个新的基提交的过程。过程一般如下所示：</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:e4a40899-636b-4988-9774-eaa8a440575b/02.svg" alt="Git Tutorial: Rebase to maintain a linear project history."></p><p>从内容的角度来看，rebase 只不过是将分支从一个提交移到了另一个。但从内部机制来看，Git 是通过在选定的基上创建新提交来完成这件事的——它事实上重写了你的项目历史。理解这一点很重要，尽管分支看上去是一样的，但它包含了全新的提交。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;base&gt;</span><br></pre></td></tr></table></figure><p>将当前分支 rebase 到 <code>&lt;base&gt;</code>，这里可以是任何类型的提交引用（ID、分支名、标签，或是 <code>HEAD</code> 的相对引用）。</p><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><p>rebase 的主要目的是为了保持一个线性的项目历史。比如说，当你在 feature 分支工作时 master 分支取得了一些进展：</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:d3b2abde-d06a-47b6-8955-5f3ef34e0237/03.svg" alt="Git Rebase Branch onto Master"></p><p>要将你的 feature 分支整合进 <code>master</code> 分支，你有两个选择：直接 merge，或者先 rebase 后 merge。前者会产生一个三路合并（3-way merge）和一个合并提交，而后者产生的是一个快速向前的合并以及完美的线性历史。下图展示了为什么 rebase 到 <code>master</code> 分支会促成一个快速向前的合并。</p><p><img src="https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/04.svg" alt="Git Tutorial: Fast-forward merge"></p><p>rebase 是将上游更改合并进本地仓库的通常方法。你每次想查看上游进展时，用 <code>git merge</code> 拉取上游更新会导致一个多余的合并提交。在另一方面，rebase 就好像是说「我想将我的更改建立在其他人的进展之上」。</p><h4 id="不要-rebase-公共历史"><a href="#不要-rebase-公共历史" class="headerlink" title="不要 rebase 公共历史"></a>不要 rebase 公共历史</h4><p>和我们讨论过的 <code>git commit --amend</code> 和 <code>git reset</code> 一样，你永远不应该 rebase 那些已经推送到公共仓库的提交。rebase 会用新的提交替换旧的提交，你的项目历史会像突然消失了一样。</p><h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个🌰同时使用 git rebase 和 git merge 来保持线性的项目历史。这是一个确认你的合并都是快速向前的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开始新的功能分支</span><br><span class="line">git checkout -b new-feature master</span><br><span class="line"># 编辑文件</span><br><span class="line">git commit -a -m &quot;Start developing a feature&quot;</span><br></pre></td></tr></table></figure><p>在 feature 分支开发了一半的时候，我们意识到项目中有一个安全漏洞:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基于master分支创建一个快速修复分支</span><br><span class="line">git checkout -b hotfix master</span><br><span class="line"># 编辑文件</span><br><span class="line">git commit -a -m &quot;Fix security hole&quot;</span><br><span class="line"># 合并回master</span><br><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line">git branch -d hotfix</span><br></pre></td></tr></table></figure><p>将 hotfix 分支并回之后 master，我们有了一个分叉的项目历史。我们用 rebase 整合 feature 分支以获得线性的历史，而不是使用普通的 git merge。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout new-feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>它将 new-feature 分支移到了 master 分支的末端，现在我们可以在 master 上进行标准的快速向前合并了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><h2 id="git-rebase-i"><a href="#git-rebase-i" class="headerlink" title="git rebase -i"></a>git rebase -i</h2><p>用 <code>-i</code> 标记运行 <code>git rebase</code> 开始交互式 rebase。交互式 rebase 给你在过程中修改单个提交的机会，而不是盲目地将所有提交都移到新的基上。你可以移除、分割提交，更改提交的顺序。它就像是打了鸡血的 <code>git commit --amend</code> 一样。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;base&gt;</span><br></pre></td></tr></table></figure><p>将当前分支 rebase 到 <code>base</code>，但使用可交互的形式。它会打开一个编辑器，你可以为每个将要 rebase 的提交输入命令（见后文）。这些命令决定了每个提交将会怎样被转移到新的基上去。你还可以对这些提交进行排序。</p><h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><p>交互式 rebase 给你了控制项目历史的完全掌控。它给了开发人员很大的自由，因为他们可以提交一个「混乱」的历史而只需专注于写代码，然后回去恢复干净。</p><p>大多数开发者喜欢在并入主代码库之前用交互式 rebase 来完善他们的 feature 分支。他们可以将不重要的提交合在一起，删除不需要的，确保所有东西在提交到「正式」的项目历史前都是整齐的。对其他人来说，这个功能的开发看上去是由一系列精心安排的提交组成的。</p><h3 id="栗子-2"><a href="#栗子-2" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个🌰是 <code>非交互式rebase</code> 一节中🌰的可交互升级版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 开始新的功能分支</span><br><span class="line">git checkout -b new-feature master</span><br><span class="line"># 编辑文件</span><br><span class="line">git commit -a -m &quot;Start developing a feature&quot;</span><br><span class="line"># 编辑更多文件</span><br><span class="line">git commit -a -m &quot;Fix something from the previous commit&quot;</span><br><span class="line"></span><br><span class="line"># 直接在 master 上添加文件</span><br><span class="line">git checkout master</span><br><span class="line"># 编辑文件</span><br><span class="line">git commit -a -m &quot;Fix security hole&quot;</span><br><span class="line"></span><br><span class="line"># 开始交互式 rebase</span><br><span class="line">git checkout new-feature</span><br><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure><p>最后的那个命令会打开一个编辑器，包含 new-feature 的两个提交，和一些指示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 32618c4 Start developing a feature</span><br><span class="line">pick 62eed47 Fix something from the previous commit</span><br></pre></td></tr></table></figure><p>你可以更改每个提交前的 pick 命令来决定在 rebase 时提交移动的方式。在我们的例子中，我们只需要用 squash 命令把两个提交并在一起就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 32618c4 Start developing a feature</span><br><span class="line">squash 62eed47 Fix something from the previous commit</span><br></pre></td></tr></table></figure><p>保存并关闭编辑器以开始 rebase。另一个编辑器会打开，询问你合并后的快照的提交信息。在定义了提交信息之后，rebase 就完成了，你可以在 <code>git log</code> 输出中看到那个提交。整个过程可以用下图可视化：</p><p><img src="https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/05.svg" alt="Git Tutorial: git rebase -i example"></p><p>注意缩并的提交和原来的两个提交的 ID 都不一样，告诉我们这确实是个新的提交。</p><p>最后，你可以执行一个快速向前的合并，来将完善的 feature 分支整合进主代码库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><p>交互式 rebase 强大的能力可以从整合后的 master 分支看出——额外的 <code>62eed47</code> 提交找不到了。对其他人来说，你就像是一个天才，用完美数量的提交完成了 <code>new-feature</code>。这就是交互式提交如何保持项目历史干净和合意。</p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p>Git 用引用日志这种机制来记录分支顶端的更新。它允许你回到那些不被任何分支或标签引用的更改。在重写历史后，引用日志包含了分支旧状态的信息，有需要的话你可以回到这个状态。</p><h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>显示本地仓库的引用日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog --relative-date</span><br></pre></td></tr></table></figure><p>用相对的日期显示引用日志。(如 2 周前）。</p><h3 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h3><p>每次当前的 HEAD 更新时（如切换分支、拉取新更改、重写历史或只是添加新的提交），引用日志都会添加一个新条目。</p><h3 id="栗子-3"><a href="#栗子-3" class="headerlink" title="栗子"></a>栗子</h3><p>为了理解 <code>git reflog</code>，我们来看一个🌰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure><p>上面的引用日志显示了 master 和 2.2 的 branch 之间的相互切换。还有对一个更老的提交的强制重设。最近的活动用 <code>HEAD@&#123;0&#125;</code> 标记在上方显示。</p><p>如果事实上你是不小心切换回去的，引用日志包含了你意外地丢掉两个提交之前 master 指向的提交 0254ea7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 0254ea7</span><br></pre></td></tr></table></figure><p>使用 <a href="https://jinbilianshao.github.io/wikicode/wiki/7-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9/"><code>git reset</code></a>，就有可能能将master变回之前的那个提交。它提供了一张安全网，以防历史发生意外更改。</p><p>务必记住，引用日志提供的安全网只对提交到本地仓库的更改有效，而且只有移动操作会被记录。</p><blockquote><p>这篇文章参考于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「git-recipes」</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重写项目历史&quot;&gt;&lt;a href=&quot;#重写项目历史&quot; class=&quot;headerlink&quot; title=&quot;重写项目历史&quot;&gt;&lt;/a&gt;重写项目历史&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>7.回滚错误的修改</title>
    <link href="https://jinbilianshao.github.io/wiki/7-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <id>https://jinbilianshao.github.io/wiki/7-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9/</id>
    <published>2023-03-01T14:55:00.000Z</published>
    <updated>2023-03-01T15:02:22.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回滚错误的修改"><a href="#回滚错误的修改" class="headerlink" title="回滚错误的修改"></a>回滚错误的修改</h2><p>这章教程提供了和项目旧版本打交道所需要的所有技巧。首先，你会知道如何浏览旧的提交，然后了解回滚项目历史中的公有提交和回滚本地机器上的私有更改之间的区别。</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>见上一章<a href="https://jinbilianshao.github.io/wikicode/wiki/6-%E6%A3%80%E5%87%BA%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4/">「6.检出历史提交」</a>。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p><code>git revert</code> 命令用来撤销一个已经提交的快照。但是，它是通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 <em>新</em> 提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:b6fcf82b-5b15-4569-8f4f-a76454f9ca5b/03%20(7" alt="Git Tutorial: git revert"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>生成一个撤消了 <code>&lt;commit&gt;</code> 引入的修改的新提交，然后应用到当前分支。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>撤销（revert）应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 <code>git revert</code>，它帮你做了所有的事情。</p><h4 id="撤销（revert）和重设（reset）对比"><a href="#撤销（revert）和重设（reset）对比" class="headerlink" title="撤销（revert）和重设（reset）对比"></a>撤销（revert）和重设（reset）对比</h4><p>理解这一点很重要。<code>git revert</code> 回滚了「单独一个提交」，它没有移除后面的提交，然后回到项目之前的状态。在 Git 中，后者实际上被称为 <code>reset</code>，而不是 <code>revert</code>。</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:a6a50d78-48e3-4765-8492-9e48dec8fd2f/04%20(2).svg" alt="Git Tutorial: Revert vs Reset"></p><p>撤销和重设相比有两个重要的优点。首先，它不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。至于为什么改变共享的历史是危险的，请参阅 <code>git reset</code> 一节。</p><p>其次，<code>git revert</code> 可以针对历史中任何一个提交，而 <code>git reset</code> 只能从当前提交向前回溯。比如，你想用 <code>git reset</code> 重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。不用说，这并不是一个优雅的回滚方案。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>如果说 <code>git revert</code> 是一个撤销更改安全的方式，你可以将 <code>git reset</code> 看做一个 <em>危险</em> 的方式。当你用 <code>git reset</code> 来重设更改时(提交不再被任何引用或引用日志所引用)，我们无法获得原来的样子——这个撤销是永远的。使用这个工具的时候务必要小心，因为这是少数几个可能会造成工作丢失的命令之一。</p><p>和 <code>git checkout</code> 一样，<code>git reset</code> 有很多种用法。它可以被用来移除提交快照，尽管它通常被用来撤销缓存区和工作目录的修改。不管是哪种情况，它应该只被用于 <em>本地</em> 修改——你永远不应该重设和其他开发者共享的快照。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt;</span><br></pre></td></tr></table></figure><p>从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure><p>重设缓冲区，匹配最近的一次提交，但工作目录不变。它会取消 <em>所有</em> 文件的缓存，而不会覆盖任何修改，给你了一个重设缓存快照的机会。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><p>重设缓冲区和工作目录，匹配最近的一次提交。除了取消缓存之外，<code>--hard</code> 标记告诉 Git 还要重写所有工作目录中的更改。换句话说：它清除了所有未提交的更改，所以在使用前确定你想扔掉你所有本地的开发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>将当前分支的末端移到 <code>&lt;commit&gt;</code>，将缓存区重设到这个提交，但不改变工作目录。所有 <code>&lt;commit&gt;</code> 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>将当前分支的末端移到 <code>&lt;commit&gt;</code>，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 <code>&lt;commit&gt;</code> 之后的所有提交。</p><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><p>上面所有的调用都是用来移除仓库中的修改。没有 <code>--hard</code> 标记时 <code>git reset</code> 通过取消缓存或取消一系列的提交，然后重新构建提交来清理仓库。而加上 <code>--hard</code> 标记对于作了大死之后想要重头再来尤其方便。</p><p>撤销(revert)被设计为撤销 <em>公开</em> 的提交的安全方式，<code>git reset</code>被设计为重设 <em>本地</em> 更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。</p><p><img src="https://www.atlassian.com/git/images/tutorials/getting-started/undoing-changes/06.svg" alt="Git Tutorial: Revert vs Reset"></p><h4 id="不要重设公共历史"><a href="#不要重设公共历史" class="headerlink" title="不要重设公共历史"></a>不要重设公共历史</h4><p>当有 <code>&lt;commit&gt;</code> 之后的提交被推送到公共仓库后，你绝不应该使用 <code>git reset</code>。发布一个提交之后，你必须假设其他开发者会依赖于它。</p><p>移除一个其他团队成员在上面继续开发的提交在协作时会引发严重的问题。当他们试着和你的仓库同步时，他们会发现项目历史的一部分突然消失了。下面的序列展示了如果你尝试重设公共提交时会发生什么。<code>origin/master</code> 是你本地 <code>master</code> 分支对应的中央仓库中的分支。</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:b616f03d-5257-4ea8-a6eb-db1a0207a78a/07%20(1).svg" alt="Git Tutorial: Resetting an Public Commit"></p><p>一旦你在重设之后又增加了新的提交，Git 会认为你的本地历史已经和 <code>origin/master</code> 分叉了，同步你的仓库时的合并提交（merge commit）会使你的同事困惑。</p><p>重点是，确保你只对本地的修改使用 <code>git reset</code>，而不是公共更改。如果你需要修复一个公共提交，<code>git revert</code> 命令正是被设计来做这个的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="取消文件缓存"><a href="#取消文件缓存" class="headerlink" title="取消文件缓存"></a>取消文件缓存</h4><p><code>git reset</code> 命令在准备缓存快照时经常被用到。下面的例子假设你有两个文件，<code>hello.py</code> 和 <code>main.py</code>它们已经被加入了仓库中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 编辑了hello.py和main.py</span><br><span class="line"></span><br><span class="line"># 缓存了目录下所有文件</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"># 意识到hello.py和main.py中的修改</span><br><span class="line"># 应该在不同的快照中提交</span><br><span class="line"></span><br><span class="line"># 取消main.py缓存</span><br><span class="line">git reset main.py</span><br><span class="line"></span><br><span class="line"># 只提交hello.py</span><br><span class="line">git commit -m &quot;Make some changes to hello.py&quot;</span><br><span class="line"></span><br><span class="line"># 在另一份快照中提交main.py</span><br><span class="line">git add main.py</span><br><span class="line">git commit -m &quot;Edit main.py&quot;</span><br></pre></td></tr></table></figure><p>如你所见，<code>git reset</code> 帮助你取消和这次提交无关的修改，让提交能够专注于某一特定的范围。</p><h4 id="移除本地修改"><a href="#移除本地修改" class="headerlink" title="移除本地修改"></a>移除本地修改</h4><p>下面的这个栗子显示了一个更高端的用法。它展示了你作了大死之后应该如何扔掉那几个更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个叫`foo.py`的新文件，增加代码</span><br><span class="line"></span><br><span class="line"># 提交到项目历史</span><br><span class="line">git add foo.py</span><br><span class="line">git commit -m &quot;Start developing a crazy feature&quot;</span><br><span class="line"></span><br><span class="line"># 再次编辑`foo.py`，修改其他文件</span><br><span class="line"></span><br><span class="line"># 提交另一份快照</span><br><span class="line">git commit -a -m &quot;Continue my crazy feature&quot;</span><br><span class="line"></span><br><span class="line"># 决定废弃这个功能，并删除相关的更改</span><br><span class="line">git reset --hard HEAD~2</span><br></pre></td></tr></table></figure><p><code>git reset HEAD~2</code> 命令将当前分支向前倒退两个提交，相当于在项目历史中移除刚创建的这两个提交。记住，这种重设只能用在 <em>非公开</em> 的提交中。绝不要在将提交推送到共享仓库之后执行上面的操作。</p><h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><p><code>git clean</code> 命令将未跟踪的文件从你的工作目录中移除。它只是提供了一条捷径，因为用 <code>git status</code> 查看哪些文件还未跟踪然后手动移除它们也很方便。和一般的 <code>rm</code> 命令一样，<code>git clean</code> 是无法撤消的，所以在删除未跟踪的文件之前想清楚，你是否真的要这么做。</p><p><code>git clean</code> 命令经常和 <code>git reset --hard</code> 一起使用。记住，reset 只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -n</span><br></pre></td></tr></table></figure><p>执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure><p>移除当前目录下未被跟踪的文件。<code>-f</code>（强制）标记是必需的，除非 <code>clean.requireForce</code> 配置项被设为了 <code>false</code>（默认为 <code>true</code>）。它 <em>不会</em> 删除 <code>.gitignore</code> 中指定的未跟踪的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f &lt;path&gt;</span><br></pre></td></tr></table></figure><p>移除未跟踪的文件，但限制在某个路径下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df</span><br></pre></td></tr></table></figure><p>移除未跟踪的文件，以及目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xf</span><br></pre></td></tr></table></figure><p>移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。</p><h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><p>如果你在本地仓库中作死之后想要毁尸灭迹，<code>git reset --hard</code> 和 <code>git clean -f</code> 是你最好的选择。运行这两个命令使工作目录和最近的提交相匹配，让你在干净的状态下继续工作。</p><p><code>git clean</code> 命令对于 build 后清理工作目录十分有用。比如，它可以轻易地删除 C 编译器生成的 <code>.o</code> 和 <code>.exe</code> 二进制文件。这通常是打包发布前需要的一步。<code>-x</code> 命令在这种情况下特别方便。</p><p>请牢记，和 <code>git reset</code> 一样， <code>git clean</code> 是仅有的几个可以永久删除提交的命令之一，所以要小心使用。事实上，它太容易丢掉重要的修改了，以至于 Git 厂商 <em>强制</em> 你用 <code>-f</code> 标志来进行最基本的操作。这可以避免你用一个 <code>git clean</code> 就不小心删除了所有东西。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>下面的栗子清除了工作目录中的所有更改，包括新建还没加入缓存的文件。它假设你已经提交了一些快照，准备开始一些新的实验。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 编辑了一些文件</span><br><span class="line"># 新增了一些文件</span><br><span class="line"># 『糟糕』</span><br><span class="line"></span><br><span class="line"># 将跟踪的文件回滚回去</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"># 移除未跟踪的文件</span><br><span class="line">git clean -df</span><br></pre></td></tr></table></figure><p>在执行了 reset/clean 的流程之后，工作目录和缓存区和最近一次提交看上去一模一样，而  <code>git status</code>会认为这是一个干净的工作目录。你可以重新来过了。</p><p>注意，不像 <code>git reset</code> 的第二个栗子，新的文件没有被加入到仓库中。因此，它们不会受到 <code>git reset --hard</code> 的影响，需要 <code>git clean</code> 来删除它们。</p><blockquote><p>这是一篇在<a href="https://www.atlassian.com/git/tutorials/undoing-changes">原文（BY atlassian）</a>基础上演绎的译文。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回滚错误的修改&quot;&gt;&lt;a href=&quot;#回滚错误的修改&quot; class=&quot;headerlink&quot; title=&quot;回滚错误的修改&quot;&gt;&lt;/a&gt;回滚错误的修改&lt;/h2&gt;&lt;p&gt;这章教程提供了和项目旧版本打交道所需要的所有技巧。首先，你会知道如何浏览旧的提交，然后了解回滚项目历</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>6.检出历史提交</title>
    <link href="https://jinbilianshao.github.io/wiki/6-%E6%A3%80%E5%87%BA%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4/"/>
    <id>https://jinbilianshao.github.io/wiki/6-%E6%A3%80%E5%87%BA%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4/</id>
    <published>2023-03-01T14:53:00.000Z</published>
    <updated>2023-03-01T14:54:58.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检出历史提交"><a href="#检出历史提交" class="headerlink" title="检出历史提交"></a>检出历史提交</h2><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p><code>git checkout</code> 这个命令有三个不同的作用：检出文件、检出提交和检出分支。在这一章中，我们只关心前两种用法。</p><p>检出提交会使工作目录和这个提交完全匹配。你可以用它来查看项目之前的状态，而不改变当前的状态。检出文件使你能够查看某个特定文件的旧版本，而工作目录中剩下的文件不变。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>回到 master 分支。分支会在下一节中讲到，而现在，你只需要将它视为回到项目「当前」状态的一种方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p>查看文件之前的版本。它将工作目录中的 <code>&lt;file&gt;</code> 文件变成 <code>&lt;commit&gt;</code> 中那个文件的拷贝，并将它加入缓存区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 <code>&lt;commit&gt;</code> 参数。这会使你处在分离 HEAD 的状态。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>版本控制系统背后的思想就是「安全」地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库。当你建立了项目历史之后，<code>git checkout</code> 是一种便捷的方式，来将保存的快照「加载」到你的开发机器上去。</p><p>检出之前的提交是一个只读操作。在查看旧版本的时候绝不会损坏你的仓库。你项目「当前」的状态在    <code>master</code> 上不会变化。在开发的正常阶段，<code>HEAD</code> 一般指向 master 或是其他的本地分支，但当你检出之前提交的时候，<code>HEAD</code> 就不再指向一个分支了——它直接指向一个提交。这被称为「分离 <code>HEAD</code>」状态 ，可以用下图可视化：</p><p><img src="https://www.atlassian.com/git/images/tutorials/getting-started/viewing-old-commits/01.svg" alt="Git Tutorial: Checking out a previous commit"></p><p>在另一方面，检出旧文件不影响你仓库的当前状态。你可以在新的快照中像其他文件一样重新提交旧版本。所以，在效果上，<code>git checkout</code> 的这个用法可以用来将单个文件回滚到旧版本 。</p><p><img src="https://www.atlassian.com/git/images/tutorials/getting-started/viewing-old-commits/02.svg" alt="Git Training: Checking out a previous version of a file"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="查看之前的版本"><a href="#查看之前的版本" class="headerlink" title="查看之前的版本"></a>查看之前的版本</h4><p>这个栗子假定你开始了一个疯狂的实验，但你不确定你是否想要保留它。为了帮助你决定，你想看一看你开始实验之前的项目状态。首先，你需要找到你想要看的那个版本的 ID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>假设你的项目历史看上去和下面一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b7119f2 继续做些丧心病狂的事</span><br><span class="line">872fa7e 做些丧心病狂的事</span><br><span class="line">a1e8fb5 对 hello.py 做了一些修改</span><br><span class="line">435b61d 创建 hello.py</span><br><span class="line">9773e52 初始导入</span><br></pre></td></tr></table></figure><p>你可以这样使用 <code>git checkout</code> 来查看「对 hello.py 做了一些修改」这个提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a1e8fb5</span><br></pre></td></tr></table></figure><p>这让你的工作目录和 <code>a1e8fb5</code> 提交所处的状态完全一致。你可以查看文件，编译项目，运行测试，甚至编辑文件而不需要考虑是否会影响项目的当前状态。你所做的一切 <em>都不会</em> 被保存到仓库中。为了继续开发，你需要回到你项目的「当前」状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>这里假定了你默认在 master 分支上开发，我们会在以后的分支模型中详细讨论。</p><p>一旦你回到 master 分支之后，你可以使用 <code>git revert</code> 或 <code>git reset</code> 来回滚任何不想要的更改。</p><h4 id="检出文件"><a href="#检出文件" class="headerlink" title="检出文件"></a>检出文件</h4><p>如果你只对某个文件感兴趣，你也可以用 <code>git checkout</code> 来获取它的一个旧版本。比如说，如果你只想从之前的提交中查看 <code>hello.py</code> 文件，你可以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a1e8fb5 hello.py</span><br></pre></td></tr></table></figure><p>记住，和检出提交不同，这里 <em>确实</em> 会影响你项目的当前状态。旧的文件版本会显示为「需要提交的更改」，允许你回滚到文件之前的版本。如果你不想保留旧的版本，你可以用下面的命令检出到最近的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD hello.py</span><br></pre></td></tr></table></figure><blockquote><p>这篇教程来源于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「git-recipes」</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;检出历史提交&quot;&gt;&lt;a href=&quot;#检出历史提交&quot; class=&quot;headerlink&quot; title=&quot;检出历史提交&quot;&gt;&lt;/a&gt;检出历史提交&lt;/h2&gt;&lt;h2 id=&quot;git-checkout&quot;&gt;&lt;a href=&quot;#git-checkout&quot; class=&quot;head</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>5.查看仓库状态</title>
    <link href="https://jinbilianshao.github.io/wiki/5-%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/"/>
    <id>https://jinbilianshao.github.io/wiki/5-%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/</id>
    <published>2023-03-01T14:52:00.000Z</published>
    <updated>2023-03-01T14:53:24.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检查仓库状态"><a href="#检查仓库状态" class="headerlink" title="检查仓库状态"></a>检查仓库状态</h1><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p><code>git status</code> 命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被 Git 追踪。status 的输出 <em>不会</em> 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用 <code>git log</code> 命令。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>列出已缓存、未缓存、未追踪的文件。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>git status</code> 是一个相对简单的命令。 它告诉你 <code>git add</code> 和 <code>git commit</code> 的进展。status 信息还包括了添加缓存和移除缓存的相关指令。样例输出显示了三类主要的 <code>git status</code> 输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line"># (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#modified: hello.py</span><br><span class="line">#</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line"># (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line"># (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#modified: main.py</span><br><span class="line">#</span><br><span class="line"># Untracked files:</span><br><span class="line"># (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">#</span><br><span class="line">#hello.pyc</span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>未追踪的文件通常有两类。它们要么是项目新增但还未提交的文件，要么是像 <code>.pyc</code>、<code>.obj</code>、<code>.exe</code> 等编译后的二进制文件。显然前者应该出现在 <code>git status</code> 的输出中，而后者会让我们困惑究竟发生了什么。</p><p>因此，Git 允许你完全忽略这些文件，只需要将路径放在一个特定的 <code>.gitignore</code> 文件中。所有想要忽略的文件应该分别写在单独一行，<code>*</code> 字符用作通配符。比如，将下面这行加入项目根目录的<code>.gitignore</code>文件可以避免编译后的Python模块出现在<code>git status</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.pyc</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在提交更改前检查仓库状态是一个良好的实践，这样你就不会不小心提交什么奇怪的东西。这个例子显示了缓存和提交快照前后的仓库状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Edit hello.py</span><br><span class="line">git status</span><br><span class="line"># hello.py is listed under &quot;Changes not staged for commit&quot;</span><br><span class="line">git add hello.py</span><br><span class="line">git status</span><br><span class="line"># hello.py is listed under &quot;Changes to be committed&quot;</span><br><span class="line">git commit</span><br><span class="line">git status</span><br><span class="line"># nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p>第一个 status 的输出显示文件还未缓存。<code>git add</code> 操作会影响第二个 <code>git status</code>，最后的 status 输出告诉你已经没有可以提交的东西了——工作目录和最近的提交一致。一些 Git 命令（比如 <code>git merge</code>）需要工作目录整洁，以免意外覆盖更改。</p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p><code>git log</code> 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。<code>git status</code> 允许你查看工作目录和缓存区，而 <code>git log</code> 只作用于提交的项目历史。</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:52d530ce-7f51-48e3-920b-a18f776048d3/01.svg" alt="Git Tutorial: git status vs. git log"></p><p>log 输出可以有很多种自定义的方式，从简单地筛选提交，到用完全自定义的格式显示。其中一些最常用的 <code>git log</code> 配置如下所示。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用 <code>空格键</code> 来滚动，按 <code>q</code> 退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -n &lt;limit&gt;</span><br></pre></td></tr></table></figure><p>用 <code>&lt;limit&gt;</code> 限制提交的数量。比如 <code>git log -n 3</code> 只会显示 3 个提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>除了 <code>git log</code> 信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>显示代表每个提交的一堆信息。显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;&lt;pattern&gt;&quot;</span><br></pre></td></tr></table></figure><p>搜索特定作者的提交。<code>&lt;pattern&gt;</code> 可以是字符串或正则表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --grep=&quot;&lt;pattern&gt;&quot;</span><br></pre></td></tr></table></figure><p>搜索提交信息匹配特定 <code>&lt;pattern&gt;</code> 的提交。<code>&lt;pattern&gt;</code> 可以是字符串或正则表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;since&gt;..&lt;until&gt;</span><br></pre></td></tr></table></figure><p>只显示发生在 <code>&lt;since&gt;</code> 和 <code>&lt;until&gt;</code> 之间的提交。两个参数可以是提交 ID、分支名、<code>HEAD</code> 或是任何一种引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;file&gt;</span><br></pre></td></tr></table></figure><p>只显示包含特定文件的提交。查找特定文件的历史这样做会很方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --decorate --oneline</span><br></pre></td></tr></table></figure><p>还有一些有用的选项。<code>--graph</code> 标记会绘制一幅字符组成的图形，左边是提交，右边是提交信息。<code>--decorate</code> 标记会加上提交所在的分支名称和标签。<code>--oneline</code> 标记将提交信息显示在同一行，一目了然。</p><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><p><code>git log</code> 命令是 Git 查看项目历史的基本工具。当你要寻找项目特定的一个版本或者弄明白合并功能分支时引入了哪些变化，你就会用到这个命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7</span><br><span class="line">Author: John Smith</span><br></pre></td></tr></table></figure><p>大多数时候都很简单直接。但是，第一行需要解释下。<code>commit</code> 后面 40 个字的字符串是提交内容的 SHA-1 校验总和（checksum）。它有两个作用。一是保证提交的正确性——如果它被损坏了，提交会生成一个不同的校验总和。第二，它是提交唯一的标识 ID。</p><p>这个 ID 可以用于 <code>git log</code> 这样的命令中来引用具体的提交。比如，<code>git log 3157e..5ab91</code> 会显示所有ID在 <code>3157e</code> 和 <code>5ab91</code> 之间的提交。除了校验总和之外，分支名、HEAD 关键字也是常用的引用提交的方法。<code>HEAD</code> 总是指向当前的提交，无论是分支还是特定提交也好。</p><p><del>字符用于表示提交的父节点的相对引用。比如，`3157e</del>1<code>指向</code>3157e<code> 前一个提交,</code>HEAD~3` 是当前提交的回溯3个节点的提交。</p><p>所有这些标识方法的背后都是为了让你对特定提交进行操作。<code>git log</code> 命令一般是这些交互的起点，因为它让你找到你想要的提交。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><em>用法</em> 一节提供了 <code>git log</code> 很多的栗子，但请记住，你可以将很多选项用在同一个命令中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;John Smith&quot; -p hello.py</span><br></pre></td></tr></table></figure><p>这个命令会显示 <code>John Smith</code> 作者对 <code>hello.py</code> 文件所做的所有更改的差异比较（diff）。</p><p>..句法是比较分支很有用的工具。下面的栗子显示了在 <code>some-feature</code> 分支而不在 <code>master</code> 分支的所有提交的概览。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline master..some-feature</span><br></pre></td></tr></table></figure><blockquote><p>这篇教程来源于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「git-recipes」</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;检查仓库状态&quot;&gt;&lt;a href=&quot;#检查仓库状态&quot; class=&quot;headerlink&quot; title=&quot;检查仓库状态&quot;&gt;&lt;/a&gt;检查仓库状态&lt;/h1&gt;&lt;h2 id=&quot;git-status&quot;&gt;&lt;a href=&quot;#git-status&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>4.保存更改</title>
    <link href="https://jinbilianshao.github.io/wiki/4-%E4%BF%9D%E5%AD%98%E6%9B%B4%E6%94%B9/"/>
    <id>https://jinbilianshao.github.io/wiki/4-%E4%BF%9D%E5%AD%98%E6%9B%B4%E6%94%B9/</id>
    <published>2023-03-01T14:50:00.000Z</published>
    <updated>2023-03-01T14:51:41.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wac-cdn.atlassian.com/dam/jcr:75f75cb6-a6ab-4f0b-ab29-e366914f513c/hero.svg?cdnVersion=kg" alt="Saving changes"></p><p><em><strong>git add / git commit / git diff / git stash / .gitignore</strong></em></p><p>“保存”这个概念在 Git 等版本控制系统和 Word 等文本编辑应用中不太一样。传统软件里的“保存”在 Git 里被叫做“提交”（commit）。 我们常说的的保存可以理解成在文件系统中覆盖一个已有的文件或者创建一个新的文件。而在 Git 中，提交这个操作作用于若干个文件和目录。</p><p>在 Git 和 SVN 里保存更改也不一样。SVN 提交或检入（check-in）将会推送到远端的中央服务器。也就是说 SVN 的提交需要联网才能完全“保存”项目更改。Git 提交可以在本地完成，然后再使用<code>git push -u origin master</code>命令推送到远端服务器。这两种方法的区别体现了两种架构设计的本质区别。Git 是一个分布式的应用，而 SVN 是一个中心化的应用。分布式应用一般来说更可靠，因为它们不存在中央服务器这样的单点故障。</p><p><code>git add</code>、<code>git status</code>和<code>git commit</code>这三个命令通常一起使用，将 Git 项目当前的状态保存成一份快照。</p><p>Git 还有另一个保存机制：“储藏”（stash）。储藏是一个临时的储存区域，保存还没准备好提交的更改。储藏操作作用于工作目录，三个文件树中的第一棵。它有很多用法，访问 git stash 页面了解更多。</p><p>Git 仓库可以通过设置忽略一些文件或目录。Git 将不会保存这些文件的任何更改。Git 有多种方式管理忽略文件列表。访问 git ignore 页面了解更多 Git 忽略文件设置。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><code>git add</code> 命令将工作目录中的变化添加到暂存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，<code>git add</code> 不会实质上地影响你的仓库——在你运行 <code>git commit</code> 前更改都还没有真正被记录。</p><p>使用这些命令的同时，你还需要 <code>git status</code> 来查看工作目录和暂存区的状态。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>将 <code>&lt;file&gt;</code> 中的更改加入下次提交的缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>将 <code>&lt;directory&gt;</code> 下的更改加入下次提交的缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure><p>开始交互式的缓存，你可以选择文件的一部分加入到下次提交缓存。它会向你展示一堆更改，等待你输入一个命令。<code>y</code> 将这块更改加入缓存，<code>n</code> 忽略这块更改，<code>s</code> 将它分割成更小的块，<code>e</code> 手动编辑这块更改，以及 <code>q</code> 退出。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>git add</code> 和 <code>git commit</code> 这两个命令组成了最基本的 Git 工作流。每一个 Git 用户都需要理解这两个命令，不管他们团队的协作模型是如何的。我有一千种方式可以将项目版本记录在仓库的历史中。</p><p>在一个只有编辑、缓存、提交这样基本流程的项目上开发。首先，你要在工作目录中编辑你的文件。当你准备备份项目的当前状态时，你通过 <code>git add</code> 来缓存更改。当你对缓存的快照满意之后，你通过 <code>git commit</code> 将它提交到你的项目历史中去。</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:0f27e004-f2f5-4890-921d-65fa77ba2774/01.svg" alt="Git Tutorial: git add Snapshot"></p><p><code>git add</code> 命令不能和 <code>svn add</code> 混在一起理解，后者将文件添加到仓库中。而 <code>git add</code> 发生于更抽象的 <em>更改</em> 层面。也就是说，<code>git add</code> 在每次你修改一个文件时都需要被调用，而 <code>svn add</code> 只需要每个文件调用一次。这听上去很多余，但这样的工作流使得一个项目更容易组织。</p><h4 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h4><p>缓存区是 Git 更为独特的地方之一，如果你是从 SVN（甚至是 Mercurial）迁移而来，那你可得花点时间理解了。你可以简单地把它想成是工作目录和项目历史之间的缓冲区。</p><p>缓存允许你在实际提交到项目历史之前，将相关的更改组合成一份高度专注的快照，而不是将你上次提交以后产生的所有更改一并提交。也就是说你可以更改各种不相关的文件，然后回过去将它们按逻辑切分，将相关的更改添加到缓存，一份一份提交。在任何修改控制系统中，很重要的一点是提交必须是原子性的，以便于追踪 bug，并用最小的代价回滚更改。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>当你开始新项目的时候，<code>git add</code> 和 <code>svn import</code> 类似。为了创建当前目录的初始提交，使用下面两个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>当你项目设置好之后，新的文件可以通过路径传递给 <code>git add</code> 来添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add hello.py</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>上面的命令同样可以用于记录已有文件的更改。重复一次，Git 不会区分缓存的更改来自新文件，还是仓库中已有的文件。</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><code>git commit</code>命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 <code>git add</code> 一样，这是最重要的 Git 命令之一。</p><p>尽管和它和 <code>svn commit</code> 名字一样，但实际上它们毫无关联。快照被提交到本地仓库，不会和其他 Git 仓库有任何交互。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure><p>提交已经缓存的快照。但将 <code>&lt;message&gt;</code> 作为提交信息，而不是运行文本编辑器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure><p>提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 <code>git add</code> 添加过的文件）。</p><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><p>快照总是提交到 <em>本地</em> 仓库。这一点和 SVN 截然不同，后者的工作拷贝提交到中央仓库。而 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。</p><p>这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这对于 SVN 风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。</p><h4 id="记录快照，而不是记录差异"><a href="#记录快照，而不是记录差异" class="headerlink" title="记录快照，而不是记录差异"></a>记录快照，而不是记录差异</h4><p>SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 <em>变化</em> ，而 Git 的版本控制模型基于 <em>快照</em> 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 <em>完整内容</em> 。</p><p><img src="https://www.atlassian.com/dam/jcr:7406fe56-d36d-44cf-92e3-b28e4bae36f8/02.svg" alt="Git Tutorial: Snapshots, Not Differences"></p><p>这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。</p><p>Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>下面这个栗子假设你编辑了 <code>hello.py</code> 文件的一些内容，并且准备好将它提交到项目历史。首先，你需要用 <code>git add</code> 缓存文件，然后提交缓存的快照。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add hello.py</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>它会打开一个文件编辑器（可以通过 <code>git config</code> 设置) 询问提交信息，同时列出将被提交的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line"># (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#modified: hello.py</span><br></pre></td></tr></table></figure><p>Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Change the message displayed by hello.py</span><br><span class="line"></span><br><span class="line">- Update the sayHello() function to output the user&#x27;s name</span><br><span class="line">- Change the sayGoodbye() function to a friendlier message</span><br></pre></td></tr></table></figure><p>注意，很多开发者倾向于在提交信息中使用一般现在时态。这样看起来更像是对仓库进行的操作，让很多改写历史的操作更加符合直觉。</p><blockquote><p>这篇教程来源于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「git-recipes」</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://wac-cdn.atlassian.com/dam/jcr:75f75cb6-a6ab-4f0b-ab29-e366914f513c/hero.svg?cdnVersion=kg&quot; alt=&quot;Saving changes&quot;&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>3.创建代码仓库</title>
    <link href="https://jinbilianshao.github.io/wiki/3-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"/>
    <id>https://jinbilianshao.github.io/wiki/3-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</id>
    <published>2023-03-01T14:48:00.000Z</published>
    <updated>2023-03-01T14:50:01.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h1><p>这一章简要地带你了解一些最重要的 Git 命令。在这节中，我会向你介绍开始一个新的版本控制项目需要的所有工具，后面的几节包含了你每天都会用到的Git操作。</p><p>在这节之后，你应该能够创建一个新的 Git 仓库，缓存你的项目以免丢失，以及查看你项目的历史。</p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p><code>git init</code> 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。大多数Git命令在未初始化的仓库中都是无法使用的，所以这就是你运行新项目的第一个命令了。</p><p>运行 <code>git init</code> 命令会在你项目的根目录下创建一个新的 <code>.git</code> 目录，其中包含了你项目必需的所有元数据。除了 <code>.git</code> 目录之外，已经存在的项目不会被改变（就像 SVN 一样，Git 不强制每个子目录中都有一个 <code>.git</code> 目录）。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>将当前的目录转换成一个 Git 仓库。它在当前的目录下增加了一个 <code>.git</code> 目录，于是就可以开始记录项目版本了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 <code>directory</code>，只包含 <code>.git</code> 子目录的空目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 <code>--bare</code> 标记创建（见下面的讨论）。一般来说，用 <code>—bare</code> 标记初始化的仓库以 <code>.git</code> 结尾。比如，一个叫<code>my-project</code>的仓库，它的空版本应该保存在 <code>my-project.git</code> 目录下。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>和 SVN 相比，<code>git init</code> 命令是一个创建新的版本控制项目非常简单的途径。Git 不需要你创建仓库，导入文件，检查正在修改的拷贝。你只需要 <code>cd</code> 到你的项目目录下，运行 <code>git init</code>，你就有了一个功能强大的 Git 仓库。</p><p>但是，对大多数项目来说，<code>git init</code> 只需要在创建中央仓库时执行一次——开发者通常不会使用 <code>git init</code> 来创建他们的本地仓库。他们往往使用 <code>git clone</code> 来将已存在的仓库拷贝到他们的机器中去。</p><h4 id="裸仓库"><a href="#裸仓库" class="headerlink" title="裸仓库"></a>裸仓库</h4><p><code>-—bare</code> 标记创建了一个没有工作目录的仓库，这样我们在仓库中更改文件并且提交了。中央仓库应该总是创建成裸仓库，因为向非裸仓库推送分支有可能会覆盖已有的代码变动。将<code>-—bare</code>看成是用来将仓库标记为储存设施，而不是一个开发环境。也就是说，对于所有的 Git 工作流，中央仓库是裸仓库，开发者的本地仓库是非裸仓库。</p><p><img src="https://www.atlassian.com/dam/jcr:88f08a3d-f34e-4c8e-974c-a01f25b2eca1/01.svg"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>因为 <code>git clone</code> 创建项目的本地拷贝更为方便，<code>git init</code> 最常见的使用情景就是用于创建中央仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh &lt;user&gt;@&lt;host&gt;</span><br><span class="line"></span><br><span class="line">cd path/above/repo</span><br><span class="line"></span><br><span class="line">git init --bare my-project.git</span><br></pre></td></tr></table></figure><p>首先，你用SSH连入存放中央仓库的服务器。然后，来到任何你想存放项目的地方，最后，使用 <code>-—bare</code> 标记来创建一个中央存储仓库。开发者会将 <code>my-project.git</code> 克隆到本地的开发环境中。</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p><code>git clone</code> 命令拷贝整个 Git 仓库。这个命令就像 <code>svn checkout</code> 一样，除了「工作副本」是一个完备的Git仓库——它包含自己的历史，管理自己的文件，以及环境和原仓库完全隔离。</p><p>为了方便起见，<code>clone</code> 自动创建了一个名为 <code>origin</code> 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>将位于 <code>&lt;repo&gt;</code> 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>将位于 <code>&lt;repo&gt;</code> 的仓库克隆到本地机器上的 <code>&lt;directory&gt;</code> 目录。</p><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><p>如果项目在远程仓库已经设置完毕，<code>git clone</code> 是用户获取开发副本最常见的方式。和  <code>git init</code>相似，<code>clone</code> 通常也是一次性的操作——只要开发者获得了一份工作副本，所有版本控制操作和协作管理都是在本地仓库中完成的。</p><h4 id="仓库间协作"><a href="#仓库间协作" class="headerlink" title="仓库间协作"></a>仓库间协作</h4><p>这一点很重要，你要理解 Git 中「工作副本」的概念和 SVN 仓库 check out 下来的「工作副本」是很不一样的。和 SVN 不同的是，Git 不会区分工作副本和中央仓库——它们都是功能完备的 Git 仓库。</p><p>这就使得 Git 的协作和 SVN 截然不同。SVN 依赖于中央仓库和工作副本之间的关系，而 Git 协作模型是基于仓库和仓库之间的交互的。相对于 SVN 的提交流程，你可以在 Git 仓库之间 <code>push</code> 或 <code>pull</code> 提交。</p><p><img src="https://www.atlassian.com/dam/jcr:e5228129-76b1-4b2c-8f10-af789f2ea6c0/03.svg"></p><p><img src="https://www.atlassian.com/dam/jcr:5d68ce55-59a7-4840-a896-eb2014a9f17b/02.svg"></p><p>当然，你也完全可以给予某个特定的仓库一些特殊的含义。比如，指定某个 Git 仓库为中央仓库，你就可以用 Git 进行中央化的工作流。重点是，这是通过约定实现的，而不是写死在版本控制系统本身。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>下面这个例子演示用 SSH 用户名 john 连接到 example.com，获取远程服务器上中央仓库的本地副本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://john@example.com/path/to/my-project.git</span><br><span class="line"></span><br><span class="line">cd my-project</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始工作</span></span><br></pre></td></tr></table></figure><p>第一行命令在本地机器的 <code>my-project</code> 目录下初始化了一个新的 Git 仓库，并且导入了中央仓库中的文件。接下来，你 <code>cd</code> 到项目目录，开始编辑文件、缓存提交、和其它仓库交互。同时注意 <code>.git</code> 拓展名克隆时会被去除。它表明了本地副本的非裸状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config</span><br></pre></td></tr></table></figure><p><code>git config</code> 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &lt;name&gt;</span><br></pre></td></tr></table></figure><p>定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 <code>--global</code> 标记设置当前用户的配置项。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;name&gt;</span><br></pre></td></tr></table></figure><p>定义当前用户所有提交使用的作者姓名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure><p>定义当前用户所有提交使用的作者邮箱。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="built_in">alias</span>.&lt;alias-name&gt; &lt;git-command&gt;</span><br></pre></td></tr></table></figure><p>为Git命令创建一个快捷方式（别名）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system core.editor &lt;editor&gt;</span><br></pre></td></tr></table></figure><p>定义当前机器所有用户使用命令时用到的文本编辑器，如 <code>git commit</code>。<code>&lt;editor&gt;</code> 参数用编辑器的启动命令（如 vi）替代。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --edit</span><br></pre></td></tr></table></figure><p>用文本编辑器打开全局配置文件，手动编辑。</p><h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><p>所有配置项都储存在纯文本文件中，所以 <code>git config</code> 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 <code>--global</code> 标记。</p><p>Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。</p><ul><li><repo>/.git/config – 特定仓库的设置。</li></ul><ul><li>~/.gitconfig – 特定用户的设置。这也是 <code>--global</code> 标记的设置项存放的位置。</li></ul><ul><li>$(prefix)/etc/gitconfig – 系统层面的设置。</li></ul><p>当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line"></span><br><span class="line">name = John Smith</span><br><span class="line"></span><br><span class="line">email = john@example.com</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line"></span><br><span class="line">st = status</span><br><span class="line"></span><br><span class="line">co = checkout</span><br><span class="line"></span><br><span class="line">br = branch</span><br><span class="line"></span><br><span class="line">up = rebase</span><br><span class="line"></span><br><span class="line">ci = commit</span><br><span class="line"></span><br><span class="line">[core]</span><br><span class="line"></span><br><span class="line">editor = vim</span><br></pre></td></tr></table></figure><p>你可以用 <code>git config</code> 手动编辑这些值。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>你在安装 Git 之后想要做的第一件事是告诉它你的名字和邮箱，个性化一些默认设置。一般初始的设置过程看上去是这样的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉Git你是谁</span></span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">&quot;John Smith&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email john@example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择你喜欢的文本编辑器</span></span><br><span class="line"></span><br><span class="line">git config --global core.editor vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一些快捷方式(别名)</span></span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch</span><br><span class="line"></span><br><span class="line">git config --global alias.up rebase</span><br><span class="line"></span><br><span class="line">git config --global alias.ci commit</span><br></pre></td></tr></table></figure><p>它会生成上一节中所说的 <code>~/.gitconfig</code> 文件。</p><blockquote><p>这篇教程来源于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「git-recipes」</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建代码仓库&quot;&gt;&lt;a href=&quot;#创建代码仓库&quot; class=&quot;headerlink&quot; title=&quot;创建代码仓库&quot;&gt;&lt;/a&gt;创建代码仓库&lt;/h1&gt;&lt;p&gt;这一章简要地带你了解一些最重要的 Git 命令。在这节中，我会向你介绍开始一个新的版本控制项目需要的所有工具</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>2.git安装与初体验</title>
    <link href="https://jinbilianshao.github.io/wiki/2-git%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://jinbilianshao.github.io/wiki/2-git%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2023-03-01T14:45:00.000Z</published>
    <updated>2023-03-01T14:47:23.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-简易指南"><a href="#Git-简易指南" class="headerlink" title="Git 简易指南"></a>Git 简易指南</h1><p>这节是完全面向入门者的，我假设你从零开始创建一个项目并且想用 Git 来进行版本控制，因此本文会避开分支这些相对复杂的概念。</p><p>在这节中，我会介绍如何在你的个人项目中使用 Git，我们会讨论 Git 最基本的操作——如何初始化你的项目，如何管理新的或者已有的文件，如何在远端仓库中储存你的代码。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li><p>Mac 用户：Xcode Command Line Tools 自带 Git（<code>xcode-select --install</code>）</p></li><li><p>Linux 用户：<code>sudo apt-get install git</code></p></li><li><p>Windows 用户：下载 <a href="git-for-windows.github.io">Git SCM</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 对于 Windows 用户，安装后如果希望在全局的 cmd 中使用 Git，需要把 git.exe 加入 PATH 环境变量中，或在 Git Bash 中使用 Git。</span><br></pre></td></tr></table></figure></li></ul><h2 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>执行如下命令以创建一个本地仓库的克隆版本：</p><p><code>git clone /path/to/repository</code></p><p>如果是远端服务器上的仓库，你的命令会是这个样子：</p><p><code>git clone username@host:/path/to/repository</code> （通过 SSH）</p><p>或者：</p><p><code>git clone https:/path/to/repository.git</code> （通过 https）</p><p>比如说 <code>git clone https://github.com/geeeeeeeeek/git-recipes.git</code> 可以将 git 教程 clone 到你指定的目录。</p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p><blockquote><p>下面每一步中，你都可以通过 <code>git status</code> 来查看你的git仓库状态。</p></blockquote><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 Git 维护的三棵「树」组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p><p><img src="http://www.bootcss.com/p/git-guide/img/trees.png" alt="enter image description here"></p><blockquote><p>事实上，第三个阶段是 commit history 的图。HEAD 一般是指向最新一次 commit 的引用。现在暂时不必究其细节。</p></blockquote><h2 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h2><p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt; filename &gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是 Git 基本工作流程的第一步。使用如下命令以实际提交改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure><p>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</p><blockquote><p>在开发时，良好的习惯是根据工作进度及时 commit，并务必注意附上有意义的 commit message。创建完项目目录后，第一次提交的 commit message 一般为「Initial commit」。</p></blockquote><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>可以把 master 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><blockquote><ul><li>这里 origin 是 &lt;server&gt; 的别名，取什么名字都可以，你也可以在 push 时将 &lt;jserver&gt; 替换为 origin。但为了以后 push 方便，我们第一次一般都会先 remote add。</li><li>如果你还没有 Git 仓库，可以在 Github 等代码托管平台上创建一个空（不要自动生成 README.md）的仓库，然后将代码 push 到远端仓库。</li></ul></blockquote><h5 id="至此，你应该可以顺利地提交你的项目了。在下一节中，我们将涉及更多的命令，来完成更有用的操作。比如从远端的仓库拉取更新并且合并到你的本地，如何通过分支多人协作，如何处理不同分支的冲突等等。"><a href="#至此，你应该可以顺利地提交你的项目了。在下一节中，我们将涉及更多的命令，来完成更有用的操作。比如从远端的仓库拉取更新并且合并到你的本地，如何通过分支多人协作，如何处理不同分支的冲突等等。" class="headerlink" title="至此，你应该可以顺利地提交你的项目了。在下一节中，我们将涉及更多的命令，来完成更有用的操作。比如从远端的仓库拉取更新并且合并到你的本地，如何通过分支多人协作，如何处理不同分支的冲突等等。"></a>至此，你应该可以顺利地提交你的项目了。在下一节中，我们将涉及更多的命令，来完成更有用的操作。比如从远端的仓库拉取更新并且合并到你的本地，如何通过分支多人协作，如何处理不同分支的冲突等等。</h5><blockquote><p>本教程来源于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「Git Recipes」</strong></a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-简易指南&quot;&gt;&lt;a href=&quot;#Git-简易指南&quot; class=&quot;headerlink&quot; title=&quot;Git 简易指南&quot;&gt;&lt;/a&gt;Git 简易指南&lt;/h1&gt;&lt;p&gt;这节是完全面向入门者的，我假设你从零开始创建一个项目并且想用 Git 来进行版本控制，因此本</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>1.什么是 Git</title>
    <link href="https://jinbilianshao.github.io/wiki/1-%E4%BB%80%E4%B9%88%E6%98%AF-Git/"/>
    <id>https://jinbilianshao.github.io/wiki/1-%E4%BB%80%E4%B9%88%E6%98%AF-Git/</id>
    <published>2023-03-01T14:42:00.000Z</published>
    <updated>2023-03-01T14:45:05.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h1><p>到目前为止，Git 是世界上使用最为广泛的现代化版本控制系统。Git 最初由 Linux 系统内核的作者 Linus Torvalds 在 2005 年开始开发，目前已经是一个持续维护的成熟开源项目。如今，大量软件项目依赖 Git 进行版本管理，其中既有开源软件，也有商业软件。Git 在很多操作系统和集成开发环境（IDE）上都表现良好。绝大多数软件开发者或多或少都使用过 Git。</p><p>Git 是分布式版本管理（DVCS）的一种。CVS 和 Subversion（SVN）等集中式的版本管理软件将完整的版本历史存放在同一个地方。而在 Git 中，每个开发者的代码仓库都包含了所有变更历史。</p><p>除了分布式之外，Git 在设计之初也考虑了性能、安全性和灵活性。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>Git 的底层性能相较于其他版本管理软件有强大的优势。提交修改、创建分支、合并分支和比较版本都针对性能进行了优化。Git 中实现的算法利用了现实中代码树的特点以及它们被修改和访问的常见模式。</p><p>不同于某些版本管理软件，Git 在决定文件树的储存和版本历史时，不会被文件名的变化所愚弄——Git 关注的是文件的内容本身。毕竟，代码文件经常会被重命名、拆分和重新编排。Git 仓库中的文件对象通过差分编码（delta encoding，仅保存代码修改的差分）和压缩技术储存，并且直接保存文件夹中的内容和版本控制元数据。</p><p>分布式架构也给 Git 带来了巨大的性能优势。</p><p>比如说，有一名开发成员 Alice 修改了代码，添加了一些准备在 2.0 版本中发布的功能，然后提交了这些修改及其描述。随后，她又编写并提交了另一个新功能。很自然地，这两次修改是版本历史中两份独立的工作。Alice 又切换到了 1.3 版本的分支，修复了一个只影响这个旧版本的 bug。这次修复的目的是为了让团队在 2.0 版本还没有完成之前，发布一个 1.3.1 版本来解决旧版本中的一些 bug。Alice 可以立刻回到 2.0 版本分支，继续新功能开发。这一切都不需要网络连接，非常快速可靠，甚至可以在飞机中完成。当她准备好将这些单独提交的更改发送到远程仓库时，她只需要一个“推送”（push）命令。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Git 设计时就把托管代码的完好性作为重中之重。文件内容以及文件、目录、版本、标签和提交的关联，都通过安全的加密哈希校验算法（SHA1）保护。这可以避免代码和修改历史被不小心或者恶意改变，并且保证修改历史完全可追迹。</p><p>你可以相信在 Git 中源代码的修改历史是真实可靠的。</p><p>有一些版本管理软件无法防止版本历史之后被篡改。这对于任何依赖软件开发的团队来说都是严重的安全漏洞。</p><h3 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h3><p>Git 的关键设计目标之一就是灵活。Git 在很多方面都展现出了其灵活性：支持多种非线性的工作流，对不同规模的项目来说都很高效，并且兼容多个操作系统和协议。</p><p>Git 在设计时最重要的功能便是分支和标签（不同于 SVN），因此所有影响分支和标签的操作也都会被保存到修改历史中。不是所有的版本管理软件关注的都是这个层面的版本追踪。</p><h3 id="使用-Git-进行版本管理"><a href="#使用-Git-进行版本管理" class="headerlink" title="使用 Git 进行版本管理"></a>使用 Git 进行版本管理</h3><p>Git 对于绝大多数软件开发团队来说都是最好的选择。虽然每个团队都需要考虑自身的情况，但我们依然可以列举一些 Git 比其他版本控制系统更好的理由：</p><h4 id="Git-很好用"><a href="#Git-很好用" class="headerlink" title="Git 很好用"></a>Git 很好用</h4><p>Git 兼具大多数团队和个人开发者需要的功能、性能，安全性和灵活性。我们已经具体讨论过了这些特点。对很多团队来说，它们发现 Git 在这几点上都表现的更优秀。</p><h4 id="Git-已经成为了事实上的行业标准"><a href="#Git-已经成为了事实上的行业标准" class="headerlink" title="Git 已经成为了事实上的行业标准"></a>Git 已经成为了事实上的行业标准</h4><p>Git 使用最广泛的版本管理软件。这使得 Git 在以下这些方面具有极大的吸引力。在 Atlassian（作者所在的公司），大多数代码都是通过 Git 管理的。</p><p>大量开发者都有过 Git 的使用经历，很大一部分大学毕业生甚至只用过 Git 进行版本管理。虽然迁移到 Git 的过程中或许会经历比较陡峭的学习曲线，但是大多数员工以及未来的员工都已经具备了使用 Git 的基本技能，这意味着他们不需要额外的培训。</p><p>除了拥有大量使用者之外，Git 的普及还意味着很多第三方的服务和 IDE 都已经集成了 Git。比如我们的 DVCS 桌面客户端 <a href="https://www.atlassian.com/software/sourcetree">Source Tree</a>、项目开发管理软件 <a href="https://www.atlassian.com/software/jira">JIRA</a> 和代码托管服务 <a href="https://www.atlassian.com/software/bitbucket">Bitbucket</a>。</p><p>如果你是一个想要积累软件开发工具使用技能的新人，Git 毫无疑问是你在版本管理方面的第一选择。</p><h4 id="Git-是一个高质量的开源项目"><a href="#Git-是一个高质量的开源项目" class="headerlink" title="Git 是一个高质量的开源项目"></a>Git 是一个高质量的开源项目</h4><p>Git 本身是一个经历多年良好支持和管理的开源软件项目。Git 的维护者很好地平衡了长远的用户需求，和改进可用性和功能性的例行更新。这个开源项目的质量久经考验，无数企业都极度依赖于此。</p><p>Git 还拥有良好的社区支持和庞大的用户群体。你可以找到各种深入浅出的学习资料，包括书籍，教程，以及专题网站。你也可以找到相关的播客节目和视频教程。</p><p>开源降低了业余开发者的成本，因为他们不需要花一分钱来使用 Git。对于开源项目来说，Git 无疑是 SVN 和 CVS 等上一代流行版本管理软件的接班人。</p><h4 id="对-Git-的批评"><a href="#对-Git-的批评" class="headerlink" title="对 Git 的批评"></a>对 Git 的批评</h4><p>对于 Git 的一个常见批评是它学起来不那么容易。Git 中的某些术语对于新手或者是使用其他系统的朋友可能会比较陌生。比如说，<code>revert</code> 这个命令在 Git、SVN、CVS 中具有不同的含义。不过，Git 向用户提供了非常强大的功能。学习掌握这些功能也许会花一些时间，但是一旦你学会了这些技能，它们会帮助你大大提高团队的开发效率。</p><p>对于曾经使用非分布式版本管理的团队来说，他们可能不想放弃中央服务器。不过，虽然 Git 被设计成分布式的架构，你依然可以建立一个“官方”的代码库来存放所有的修改。使用 Git 时，由于所有的开发者都拥有完整的代码库拷贝，所以他们的工作不会被中央服务器的状态和性能所影响。即使遇到故障，他们依然可以查看完整的项目历史。得益于 Git 的灵活性和分布式特点，你可以在保持原有工作方式的同时还可以得到 Git 带来的额外好处，而你以前甚至不会意识到这些好处。</p><p>现在你已经明白了什么是版本管理，什么是 Git 以及为什么要使用 Git ，你可以选择继续阅读下一节，了解 Git 在整个组织层面带来的好处。</p><blockquote><p>本教程来源于<a href="https://github.com/geeeeeeeeek/git-recipes/"><strong>「Git Recipes」</strong></a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-Git&quot;&gt;&lt;a href=&quot;#什么是-Git&quot; class=&quot;headerlink&quot; title=&quot;什么是 Git&quot;&gt;&lt;/a&gt;什么是 Git&lt;/h1&gt;&lt;p&gt;到目前为止，Git 是世界上使用最为广泛的现代化版本控制系统。Git 最初由 Linux 系统内核的</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="git" scheme="https://jinbilianshao.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://jinbilianshao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>八.结构体</title>
    <link href="https://jinbilianshao.github.io/wiki/%E5%85%AB-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://jinbilianshao.github.io/wiki/%E5%85%AB-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2023-03-01T11:33:00.000Z</published>
    <updated>2023-03-01T12:03:11.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stu3.age = <span class="number">18</span>;</span><br><span class="line">stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：定义结构体时的关键字是struct，不可省略</p></blockquote><blockquote><p>总结2：创建结构体变量时，关键字struct可以省略</p></blockquote><blockquote><p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p></blockquote><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p><p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line"></span><br><span class="line">p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p></blockquote><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p><p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">string name;  <span class="comment">//教师姓名</span></span><br><span class="line"><span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">t1.id = <span class="number">10000</span>;</span><br><span class="line">t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">t1.stu.age = <span class="number">18</span>;</span><br><span class="line">t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu.age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printStudent</span>(stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].name = tName + nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line"><span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p><p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄信息如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">&#123;</span><br><span class="line">hero temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-基础篇结束"><a href="#C-基础篇结束" class="headerlink" title="C++基础篇结束"></a><strong>C++基础篇结束</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;8-结构体&quot;&gt;&lt;a href=&quot;#8-结构体&quot; class=&quot;headerlink&quot; title=&quot;8 结构体&quot;&gt;&lt;/a&gt;8 结构体&lt;/h2&gt;&lt;h3 id=&quot;8-1-结构体基本概念&quot;&gt;&lt;a href=&quot;#8-1-结构体基本概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term=".." scheme="https://jinbilianshao.github.io/categories/"/>
    
    <category term="C++" scheme="https://jinbilianshao.github.io/categories/C/"/>
    
    <category term="C++基础教程" scheme="https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="https://jinbilianshao.github.io/tags/c/"/>
    
    <category term="结构体" scheme="https://jinbilianshao.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
</feed>
