{"pages":[{"title":"About","date":"2023-02-27T12:48:35.326Z","path":"about/index.html","text":""},{"title":"Tags","date":"2023-02-27T12:48:35.327Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2023-02-27T12:48:35.327Z","path":"categories/index.html","text":""}],"posts":[{"title":"vi使用教程","date":"2023-03-06T07:05:00.000Z","path":"wiki/vi使用教程-1/","text":"一、关于vivi是最强大的文本编辑器，没有之一。 尽管vi已经是古董级的软件，但还是有无数新人迎着困难去学习使用，可见其经典与受欢迎的程度。 无论是小说中还是电视剧，真正强大的武器都不容易驾驭，需要付出一些努力才能收获到更加强大的力量，对于vi这种上古神器来说更是如此。 由于它全程使用键盘操作，很多首次接触 vi的人会觉得不习惯而中途放弃。然而，坚持下来的朋友就会渐渐地发现这种键盘操作的设计绝妙，经典之所以能成为经典，必然有它的道理，不用解释太多。 观察一个程序员对vi的熟练程度，可以判断它的技术水平，如果他对vi不熟悉，就肯定不是Linux平台下的程序员，说vi不好用的人也肯定不熟悉vi和Linux，没有例外。 二、创建/打开文件vi 文件名 打开一个文件，如果文件不存在，就创建它。 示例： 1vi book.c 三、vi的三种模式vi 有三种模式： 命令行模式 插入模式 替换模式 在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。 插入模式和替换模式也合称为编辑模式。 四、vi的常用命令Esc ：从编辑模式切换到命令行模式。 i ：在光标所在位置前面开始插入。 a ： 在光标所在的位置后面开始插入。 o ：在光标所在位置行的下面插入空白行。 O ：在光标所在位置行的上面插入空白行。 I ：在光标所在位置行的行首开始插入。 A ：在光标所在位置行的行末开始插入。 k ：类似方向键上。 j ：类似方向键下。 h ：类似方向键左。 l ：类是方向键右。 Ctrl+u ：向上翻半页。 Ctrl+d ：向下翻页。 Ctrl+g ：显示光标所在位置的行号和文件的总行数。 nG ：光标跳到文件的第n行行首。 G 光标跳到文件最后一行。 :5回车 光标跳到第5行。 :n回车 光标跳到第n行。 0 ：光标跳到当前行的行首。 $ ：光标跳到当前行的行尾。 w ：光标跳到下个单词的开头。 b ：光标跳到上个单词的开头。 e ：光标跳到本单词的尾部。 x ：每按一次，删除光标所在位置的一个字符。 nx ：如”3x”表示删除光标所在位置开始的3个字符。 dw ：删除光标所在位置到本单词结尾的字符。 D ：删除本行光标所在位置后面全部的内容。 dd ：删除光标所在位置的一行。 ndd ：如”3dd”表示删除光标所在位置开始的3行。 yy ：将光标所在位置的一行复制到缓冲区。 nyy ：将光标所在位置的n行复制到缓冲区。 p ：将缓冲区里的内容粘贴到光标所在位置。 r ：替换光标所在位置的一个字符 replace。 R ：从光标所在位置开始替换，直到按下”Esc”。 cw ：从光标所在位置开始替换单词，直到按下”Esc”。 u ：撤销命令，可多次撤销。 J ：把当前行的下一行接到当前行的尾部。 /abcd ：在当前打开的文件中查找“abcd”文本内容。 n ：查找下一个。 N ：查找上一下。 . ：重复执行上一次执行的vi命令。 ~ ：对光标当前所在的位置的字符进行大小写转换。 列操作 Ctrl+V ：光标上或下 大写的I 输入内容 Esc :w回车 ：存盘。 :w!回车 ：强制存盘。 :wq回车 ：存盘退出。 :x回车 ：存盘退出。 :q回车 ：不存盘退出。 :q!回车 ：不存盘强制退出。 :g/aaaaaaaaa/s//bbbbbb/g回车 ：把文件中全部的aaaaaaaaa替换成bbbbbb。 Ctl+insert ：复制鼠标选中的文本，相当于Ctl+c。 Shift+insert ：输出鼠标选中的文本，相当于Ctl+v。 以上两个命令在windows和UNIX中是通用的。","tags":[{"name":"vi","slug":"vi","permalink":"https://jinbilianshao.github.io/tags/vi/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"常用工具","slug":"/常用工具","permalink":"https://jinbilianshao.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"10.使用控制流","date":"2023-03-02T11:27:00.000Z","path":"wiki/10-使用控制流/","text":"10.使用控制流使用控制流 （Linux 环境下正常） 本章前面的示例中，已经使用过 if-else-endif 。 CMake还提供了创建循环的语言工具： foreach endforeach 和 while-endwhile 。两者都可以与 break 结合使用，以便尽早从循环中跳出。 本示例将展示如何使用 foreach ，来循环源文件列表。我们将应用这样的循环，在引入新目标的前提下，来为一组源文件进行优化降级。 具体实施 声明最低要求的 CMake 版本，项目名称和语言，并声明了库目标 1234567891011121314151617cmake_minimum_required(VERSION 3.5)project(download LIANGUAGES CXX)add_library(progressbar SHARED ProgressBar.h ProgressBar.cpp)add_library(printer SHARED Printer.h Printer.cpp)add_library(sleep SHARED Sleep.h Sleep.cpp) 使用-O3编译器优化级别编译库，对目标设置一个私有编译器选项 123456789101112target_compile_options(progressbar PRIVATE -O3)target_compile_options(Sleep PRIVATE -O3)target_compile_options( PRIVATE -O3) 然后，生成一个源文件列表，以较低的优化选项进行编译 12345678list(APPEND sources_list ProgressBar.h ProgressBar.cpp Sleep.h Sleep.cpp Printer.h Printer.cpp) 循环这些源文件，将它们的优化级别调到 -O2 。使用它们的源文件属性完成: 12345message(STATUS &quot;##### Setting source properties using IN LISTS syntax: &quot;) foreach(_source IN LISTS sources_list) set_source_files_properties($(_source) PROPERTIES COMPILE_FLAGS -O2) message(STATUS &quot;##### Appending -O2 flag for $&#123;_source&#125;&quot;) endforeach() 为了确保设置属性，再次循环并在打印每个源文件的 COMPILE_FLAGS 属性 1234foreach(_source IN LISTS sources_list) get_source_files_property(_flags $&#123;_source&#125; COMPILE_FLAGS) message(STATUS &quot;##### Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;&quot;)endforeach() 最后，添加 download 可执行目标，并将 progressbar、printer、sleep 库连接上去 12add_executable(download download.cpp)target_link_libraries(download progressbar printer sleep) 工作原理 foreach-endforeach 语法可用于在变量列表上，表示重复特定任务。 本示例中，使用它来操作、设置和获取项目中特定文件的编译器标志。CMake代码片段中引入了另外两个新命令: set_source_files_properties(file PROPERTIES property value) ，它将属性设置为给定文件的传递值。 与目标非常相似，文件在CMake中也有属性，允许对构建系统进行非常细粒度的控制。 get_source_file_property(VAR file property) ，检索给定文件所需属性的值，并将其存储在 CMake VAR 变量中。 CMake中，列表是用分号分隔的字符串组。列表可以由 list 或 set 命令创建。 例如， set(var a b c d e) 和 list(APPEND a b c d e) 都创建了列表 a;b;c;d;e 。 源码下载使用控制流源码","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"9.为语言设定标准","date":"2023-03-02T11:25:00.000Z","path":"wiki/9-为语言设定标准/","text":"9.为语言设定标准设置编译器选项 编程语言有不同的标准，即提供改进的语言版本。启用新标准是通过设置适当的编译器标志来实现的。前面的示例中，我们已经展示了如何为每个目标或全局进行配置。 3.1版本中，CMake引入了一个独立于平台和编译器的机制，用于为 C++ 和 C 设置语言标准：为目标设置 _STANDARD 属性。 具体实施 声明最低要求的 CMake 版本，项目名称和语言 12cmake_minimum_required(VERSION 3.5)project(download LIANGUAGES CXX) 要求在 Windows 上导出所有库符号 1ser(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON) 需要为库添加一个目标，这将编译源代码为一个动态库 12345add_library(progressbar SHARED ProgressBar.h ProgressBar.cpp) 现在，为目标设置了 CXX_STANDARD 、 CXX_EXTENSIONS 和 CXX_STANDARD_REQUIRED 属性。 还设置了 position_independent ent_code 属性，以避免在使用一些编译器构建 DSO 时出现问题 1234567set_target_properties( PROPERTIES CXX_STANDARD 14 CXX_EXTENSIONS OFF CXX_STANDARD_REQUIRED ON POSITION_INDEPENDENT_CODE 1) 然后，为 download 的可执行文件添加一个新目标，并设置它的属性 1234567add_executable(download download.cpp)set_target_properties(progressbar PROPERTIES CXX_STANDARD 14 CXX_EXTENSIONS OFF CXX_STANDARD_REQUIRED ON) 最后，将可执行文件链接到库 1target_link_libraries(download progressbar) 工作原理 CXX_STANDARD 会设置我们想要的标准。 CXX_EXTENSIONS 告诉 CMake，只启用 ISO C++ 标准的编译器标志，而不使用特定编译器的扩展。 CXX_STANDARD_REQUIRED 指定所选标准的版本。如果这个版本不可用，CMake将停止配置并出现错误。 当这个属性被设置为 OFF 时，CMake将寻找下一个标准的最新版本，直到一个合适的标志。 这意味着，首先查找 C++14 ，然后是 C++11 ，然后是 C++98 。","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"8.设置编译器选项","date":"2023-03-02T11:24:00.000Z","path":"wiki/8-设置编译器选项/","text":"8.设置编译器选项设置编译器选项 前面的示例展示了如何探测 CMake，从而获得关于编译器的信息，以及如何切换项目中的编译器。后一个任务是控制项目的编译器标志。CMake为调整或扩展编译器标志提供了很大的灵活性，您可以选择下面两种方法: CMake 将编译选项视为目标属性。因此，可以根据每个目标设置编译选项，而不需要覆盖 CMake 默认值。 可以使用 -D CLI 标志直接修改 CMAKE__FLAGS_ 变量。这将影响项目中的所有目标，并覆盖或扩展 CMake 默认值。 具体实施 设置CMake的最低版本: 1cmake_minimum_required(VERSION 3.5) 声明项目名称和语言 1project(hello-cmake LANGUAGES CXX) 然后，打印当前编译器标志。CMake将对所有C++目标使用这些 1message(STATUS &quot;C++ compiler flags is: $&#123;CMAKE_CXX_FLAGS&#125;&quot;) 为目标准备了标志列表，其中一些将无法在Windows上使用 12345list(APPEND flags &quot;-fPIC&quot; &quot;-Wall&quot;)if (NOT WIN32) list(APPEND flags &quot;-Wextra&quot; &quot;-Wpedantic&quot;)endif() 添加了一个新的目标—— message 库，并列出它的源依赖关系 12345add_library(message STATIC Message.h Message.cpp) 为这个库目标设置了编译选项 1234target_compile_options(message PRIVATE $&#123;flags&#125;) 然后，将生成 hello-cmake 可执行文件作为一个目标 1add_executable(hello-cmake hello-cmake.cpp) 还为可执行目标设置了编译选项 1234target_compile_options(hello-cmake PRIVATE &quot;-fPIC&quot;) 最后，将可执行文件链接到 message 库 1target_link_libraries(hello-cmake message) 如何工作 123456789101112# 本例中，警告标志有 -Wall 、 -Wextra 和 -Wpedantic ，将这些标示添加到 geometry 目标的编译选项中； compute-areas 和 geometry 目标都将使用 -fPIC 标志。# 编译选项可以添加三个级别的可见性：INTERFACE、PUBLIC 和 PRIVATE 。# 可见性的含义如下:# PRIVATE，编译选项会应用于给定的目标，不会传递给与目标相关的目标。# 我们的示例中， 即使 compute-areas 将链接到 geometry 库， compute-areas 也不会继承 geometry 目标上设置的编译器选项。# INTERFACE，给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。# PUBLIC，编译选项将应用于指定目标和使用它的目标。# 目标属性的可见性 CMake 的核心，我们将在本书中经常讨论这个话题。# 以这种方式添加编译选项，不会影响全局CMake变量 CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt; ，并能更细粒度控制在哪些目标上使用哪些选项。","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"7.切换构建类型","date":"2023-03-02T11:21:00.000Z","path":"wiki/7-切换构建类型/","text":"7.切换构建类型切换构建类型 CMake可以配置构建类型，例如：Debug、Release等。配置时，可以为Debug或Release构建设置相关的选项或属性，例如：编译器和链接器标志。控制生成构建系统使用的配置变量是CMAKE_BUILD_TYPE。该变量默认为空，CMake识别的值为:Debug： 用于在没有优化的情况下，使用带有调试符号构建库或可执行文件。Release： 用于构建的优化的库或可执行文件，不包含调试符号。RelWithDebInfo：用于构建较少的优化库或可执行文件，包含调试符号。MinSizeRel： 用于不增加目标代码大小的优化方式，来构建库或可执行文件。 具体实施 首先，定义最低CMake版本、项目名称和支持的语言： 12cmake_minimum_required(VERSION 3.5)project(hello-world LANGUAGES CXX) 然后，设置一个默认的构建类型(本例中是 Release )，并打印一条消息。要注意的是，该变量被设置为缓存变量，可以通过缓存进行编辑： 1234if (NOT CMAKE_BUILD_TYPE) set(CMAKE_BUILD_TYPE Release CACHE STRING &quot;Build type&quot; FORCE)endif()message(STATUS &quot;##### Build type is: $&#123;CMAKE_BUILD_TYPE&#125;&quot;) 打印出CMake设置的相应编译标志： 12345678message(STATUS &quot;##### C flags, Debug: $&#123;CMAKE_C_FLAGES_DEBUG&#125;&quot;)message(STATUS &quot;##### C flags, Release: $&#123;CMAKE_C_FLAGES_RELEASE&#125;&quot;)message(STATUS &quot;##### C flags, Release: $&#123;CMAKE_C_FLAGS_RELWITHDEBINFO&#125;&quot;)message(STATUS &quot;##### C flags, minimal: $&#123;CMAKE_C_FLAGS_MINISIZEREL&#125;&quot;)message(STATUS &quot;##### C++ flags, Debug: $&#123;CMAKE_CXX_FLAGS_DEBUG&#125;&quot;)message(STATUS &quot;##### C++ flags, Release: $&#123;CMAKE_CXX_FLAGS_RELEASE&#125;&quot;)message(STATUS &quot;##### C++ flags, Release: $&#123;CMAKE_CXX_FELWITHDEBINFO&#125;&quot;)message(STATUS &quot;##### C++ flags, Minimal: $&#123;CMAKE_CXX_FLAGS_MINISIZEREL&#125;&quot;) 验证配置输出 12345678910111213141516171819202122232425262728293031323334$ mkdir build$ cd build$ cmake ..-- The CXX compiler identification is GNU 10.2.0-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- ##### Build type is: Release-- ##### C flags, Debug configuration:-- ##### C flags, Release configuration:-- ##### C flags, Release configuration with Debug info:-- ##### C flags, minimal Release configuration:-- ##### C++ flags, Debug configuration: -g-- ##### C++ flags, Release configuration: -O3 -DNDEBUG-- ##### C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG-- ##### C++ flags, minimal Release configuration: -Os -DNDEBUG-- Configuring done-- Generating done-- Build files have been written to: /d/Databases/Desktop/cmake/build# 构建$ cmake --build .[ 33%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o[ 66%] Building CXX object CMakeFiles/hello-world.dir/Message.cpp.o[100%] Linking CXX executable hello-world.exe[100%] Built target hello-world$ lsCMakeCache.txt CMakeFiles Makefile cmake_install.cmake hello-world.exe 切换构建类型 12345678910111213141516171819202122232425262728293031$ cmake -D CMAKE_BUILD_TYPE=Debug ..-- The CXX compiler identification is GNU 10.2.0-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- ##### Build type is: Debug-- ##### C flags, Debug configuration:-- ##### C flags, Release configuration:-- ##### C flags, Release configuration with Debug info:-- ##### C flags, minimal Release configuration:-- ##### C++ flags, Debug configuration: -g-- ##### C++ flags, Release configuration: -O3 -DNDEBUG-- ##### C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG-- ##### C++ flags, minimal Release configuration: -Os -DNDEBUG-- Configuring done-- Generating done-- Build files have been written to: /d/Databases/Desktop/cmake/build$ cmake --build .[ 33%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o[ 66%] Building CXX object CMakeFiles/hello-world.dir/Message.cpp.o[100%] Linking CXX executable hello-world.exe[100%] Built target hello-world$ lsCMakeCache.txt CMakeFiles Makefile cmake_install.cmake hello-world.exe 多参数构建 1234567891011121314151617181920212223242526272829303132333435# 同时构建 Release 和 静态库$ cmake -D CMAKE_BUILD_TYPE=Release -D USE_LIBRARY=ON ..-- The CXX compiler identification is GNU 10.2.0-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- ##### Build type is: Release-- ##### C flags, Debug configuration:-- ##### C flags, Release configuration:-- ##### C flags, Release configuration with Debug info:-- ##### C flags, minimal Release configuration:-- ##### C++ flags, Debug configuration: -g-- ##### C++ flags, Release configuration: -O3 -DNDEBUG-- ##### C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG-- ##### C++ flags, minimal Release configuration: -Os -DNDEBUG-- Configuring done-- Generating done-- Build files have been written to: /d/Databases/Desktop/cmake/build$ cmake --build .[ 25%] Building CXX object CMakeFiles/message.dir/Message.cpp.o[ 50%] Linking CXX static library libmessage.a[ 50%] Built target message[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o[100%] Linking CXX executable hello-world.exe[100%] Built target hello-world# 编译出 libmessage.a$ lsCMakeCache.txt CMakeFiles Makefile cmake_install.cmake hello-world.exe libmessage.a 工作原理 我们演示了如何设置默认构建类型，以及如何(从命令行)覆盖它。这样，就可以控制项目，是使用优化，还是关闭优化启用调试。 我们还看到了不同配置使用了哪些标志，这主要取决于选择的编译器。 需要在运行CMake时显式地打印标志，也可以仔细阅读运行CMake --system-information的输出，以了解当前平台、默认编译器和语言的默认组合是什么。 示例1234567891011121314151617181920212223242526272829cmake_minimum_required(VERSION 3.5)project(hello-cmake LANGUAGES CXX)if (NOT CMAKE_BUILD_TYPE) set(CMAKE_BUILD_TYPE Release CACHE STRING &quot;Build type&quot; FORCE)endif()option(USE_LIBRARY OFF)list(APPEND _sources Message.h Message.cpp)message(STATUS &quot;##### Build type is: $&#123;CMAKE_BUILD_TYPE&#125;&quot;)message(STATUS &quot;##### C flags, Debug configuration: $&#123;CMAKE_C_FLAGS_DEBUG&#125;&quot;)message(STATUS &quot;##### C flags, Release configuration: $&#123;CMAKE_C_FLAGS_RELEASE&#125;&quot;)message(STATUS &quot;##### C flags, Release configuration with Debug info: $&#123;CMAKE_C_FLAGS_RELWITHDEBINFO&#125;&quot;)message(STATUS &quot;##### C flags, minimal Release configuration: $&#123;CMAKE_C_FLAGS_MINSIZEREL&#125;&quot;)message(STATUS &quot;##### C++ flags, Debug configuration: $&#123;CMAKE_CXX_FLAGS_DEBUG&#125;&quot;)message(STATUS &quot;##### C++ flags, Release configuration: $&#123;CMAKE_CXX_FLAGS_RELEASE&#125;&quot;)message(STATUS &quot;##### C++ flags, Release configuration with Debug info: $&#123;CMAKE_CXX_FLAGS_RELWITHDEBINFO&#125;&quot;)message(STATUS &quot;##### C++ flags, minimal Release configuration: $&#123;CMAKE_CXX_FLAGS_MINSIZEREL&#125;&quot;)if (USE_LIBRARY) add_library(message $&#123;_sources&#125;) add_executable(hello-world hello-world.cpp) target_link_libraries(hello-world message)else() add_executable(hello-world hello-world.cpp $&#123;_sources&#125;)endif()","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"6.指定编译器","date":"2023-03-02T11:13:00.000Z","path":"wiki/6-指定编译器/","text":"指定编译器 目前为止，我常用的编译器都集中在交叉编译，例如arm，arm64等。 CMake可以根据平台和生成器选择编译器，还能将编译器标志设置为默认值。 然而，我们通常控制编译器的选择。 在后面的示例中，我们还将考虑构建类型的选择，并展示如何控制编译器标志。 具体实施 CMake将语言的编译器存储在 CMAKE__COMPILER 变量中，其中 是受支持的任何一种语言， 对于我们的目的是 CXX 、 C 或 Fortran 。用户可以通过以下两种方式之一设置此变量： ``` cmake使用CLI中的 -D 选项，例如：cmake -D CMAKE_CXX_COMPILER=clang++ ..123452. ``` cmake # 通过导出环境变量 CXX (C++编译器)、 CC (C编译器)和 FC (Fortran编译器)。 # 例如，使用这个命令使用 clang++ 作为 C++ 编译器： env CXX=clang++ cmake .. 编译器选项 CMAKE_CXX_COMPILER CMAKE_C_COMPILER CMAKE_Fortran_COMPILER 实例运行输出结果12345678910111213141516171819202122232425$ cmake ..-- Building for: Visual Studio 16 2019-- Selecting Windows SDK version 10.0.19041.0 to target Windows 10.0.19042.-- The C compiler identification is MSVC 19.29.30038.1-- The CXX compiler identification is MSVC 19.29.30038.1-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- ##### Is the C++ compiler loaded? 1 #####-- ##### The C++ compiler ID is: MSVC #####-- ##### Is the C++ from GNU? #####-- ##### The C++ compiler version is: 19.29.30038.1 #####-- ##### Is the C compiler loaded? 1 #####-- ##### The C compiler ID is: MSVC #####-- ##### Is the C++ from GNU? #####-- ##### The C compiler version is: 19.29.30038.1 #####-- Configuring done CMakeLists.txt文件在CMakeLists.txt文件中通常如下指定，不用是注释掉，用的时候取消注释。 123456789#[[#FTset(CMAKE_SYSTEM_NAME Linux)set(CMAKE_C_COMPILER &quot;/bin/aarch64-linux-gnu-gcc&quot;)set(CMAKE_CXX_COMPILER &quot;/bin/aarch64-linux-gnu-g++&quot;)]]#[[#7045set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_C_COMPILER &quot;/bin/arm-linux-gnueabihf-gcc&quot;)set(CMAKE_CXX_COMPILER &quot;/bin/arm-linux-gnueabihf-g++&quot;)]] 例子1：CMakeLists.txt 12345678910111213141516171819# 注意，这个例子不包含任何目标，没有要构建的东西，我们只关注配置步骤:cmake_minimum_required(VERSION 3.5)project(hello-world LANGUAGES C CXX)message(STATUS &quot;##### Is the C++ compiler loaded? $&#123;CMAKE_CXX_COMPILER_LOADED&#125;&quot;)if ($&#123;CMAKE_CXX_COMPILER_LOADED&#125;) message(STATUS &quot;##### The C++ compiler ID is: $&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;) message(STATUS &quot;##### Is the C++ from GNU? $&#123;CMAKE_COMPILER_IS_GNUCXX&#125;&quot;) message(STATUS &quot;##### The C++ compiler version is: $&#123;CMAKE_CXX_COMPILER_VERSION&#125;&quot;)endif()message(STATUS &quot;##### Is the C compiler loaded? $&#123;CMAKE_C_COMPILER_LOADED&#125;&quot;)if ($&#123;CMAKE_C_COMPILER_LOADED&#125;) message(STATUS &quot;##### The C compiler ID is: $&#123;CMAKE_C_COMPILER_ID&#125;&quot;) message(STATUS &quot;##### Is the C++ from GNU? $&#123;CMAKE_COMPILER_IS_GNUCC&#125;&quot;) message(STATUS &quot;##### The C compiler version is: $&#123;CMAKE_C_COMPILER_VERSION&#125;&quot;)endif() 例子2：CMakeLists.txt 1234567891011121314151617181920cmake_minimum_required(VERSION 3.5)project(hello-world LANGUAGES C CXX)option(CMAKE_CXX_COMPILER clang++)message(STATUS &quot;##### 编译器：$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;)message(STATUS &quot;##### 编译器版本：$&#123;CMAKE_CXX_COMPILER_VERSION&#125;&quot;)option(USE_LIBRARY OFF)message(STATUS &quot;##### USE_LIBRARY? $&#123;USE_LIBRARY&#125;&quot;)list(APPEND _sources Message.h Message.cpp)if ($&#123;USE_LIBRARY&#125;) add_library(message $&#123;_sources&#125;) add_executable(hello-world hello-world.cpp) target_link_libraries(hello-world message)else() add_executable(hello-world hello-world.cpp message)endif()","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"5.向用户显示选项","date":"2023-03-02T11:10:00.000Z","path":"wiki/5-向用户显示选项/","text":"5.向用户显示选项向用户显示选项 前面的配置中，我们引入了条件句：通过硬编码的方式给定逻辑变量值。不过，这会影响用户修改这些变量。 CMake代码没有向读者传达，该值可以从外部进行修改。推荐在 CMakeLists.txt 中使用 option() 命令， 以选项的形式显示逻辑开关，用于外部设置，从而切换构建系统的生成行为。 本节的示例将向您展示，如何使用这个命令。 具体实施 ``` cmake用一个选项替换上一个示例的 set(USE_LIBRARY OFF) 命令。该选项将修改 USE_LIBRARY 的值，并设置其默认值为 OFF ：option(USE_LIBRARY “Compile sources into a library” OFF)1234567892. ``` shell # 现在，可以通过CMake的 -D CLI 选项，将信息传递给 CMake 来切换库的行为： # -D 开关用于为 CMake 设置任何类型的变量：逻辑变量、路径等等。 $ mkdir build $ cd build $ cmake -D USE_LIBRARY=ON .. $ $ cmake --build . 工作原理 option 可接受三个参数：option( “help string” [initial value]) ​ 表示该选项的变量的名称。​ “help string” 记录选项的字符串，在CMake的终端或图形用户界面中可见。​ [initial value] 选项的默认值，可以是 ON 或 OFF 。","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"4.用条件句控制编译","date":"2023-03-02T11:08:00.000Z","path":"wiki/4-用条件句控制编译/","text":"4.用条件句控制编译实现效果 将 Message.hpp 和 Message.cpp 构建成一个库(静态或动态)，然后将生成库链接到 hello-world 可执行文件中。 将 Message.hpp ， Message.cpp 和 hello-world.cpp 构建成一个可执行文件，但不生成任何一个库。 实现方法 ```cmake 首先，定义最低CMake版本、项目名称和支持的语言：cmake_minimum_required(VERSION 3.5) project(hello-world LANGUAGES CXX) 123452. ``` cmake # 我们引入了一个新变量 USE_LIBRARY ，这是一个逻辑变量，值为 OFF 。我们还打印了它的值： set(USE_LIBRARY OFF) message(STATUS &quot;Compile sources into a library? $&#123;USE_LIBRARY&#125;&quot;) ``` cmake CMake中定义 BUILD_SHARED_LIBS 全局变量，并设置为 OFF 。调用 add_library 并省略第二个参数，将构建一个静态库set(BUILD_SHARED_LIBS OFF) 12344. ``` cmake # 然后，引入一个变量 _sources，包含所有源文件和头文件： list(APPEND _sources Message.h Message.cpp) # 然后，引入一个基于 USE_LIBRARY 值的 if-else 语句。如果逻辑为真，则 Message.hpp 和 Message.cpp 将打包成一个库： if (USE_LIBRARY) add_library(message $&#123;_source&#125;) add_executable(hello-world hello-world.cpp) target_link_libraries(hello-world message) else() add_executable(hello-world hello-world.cpp $&#123;_sources&#125;) endif() 工作原理 我们介绍了两个变量： USE_LIBRARY 和 BUILD_SHARED_LIBS 。这两个变量都设置为 OFF 。 如CMake语言文档中描述，逻辑真或假可以用多种方式表示：如果将逻辑变量设置为以下任意一种： 1 、 ON 、 YES 、 true 、 Y 或非零数，则逻辑变量为 true 。如果将逻辑变量设置为以下任意一种： 0 、 OFF 、 NO 、 false 、 N 、 IGNORE、NOTFOUND 、空字符串，或者以 -NOTFOUND 为后缀，则逻辑变量为 false 。USE_LIBRARY 变量将在第一个和第二个行为之间切换。 BUILD_SHARED_LIBS 是CMake的一个全局标志。因为CMake内部要查询 BUILD_SHARED_LIBS 全局变量，所以 add_library 命令可以在不传递 STATIC/SHARED/OBJECT 参数的情况下调用；如果为 false 或未定义，将生成一个静态库。 这个例子说明，可以引入条件来控制CMake中的执行流。但是，当前的设置不允许从外部切换，不需要手动修改 CMakeLists.txt 。原则上，我们希望能够向用户开放所有设置，这样就可以在不修改构建代码的情况下调整配置，稍后将展示如何做到这一点。","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"3.构建和链接静态库和动态库","date":"2023-03-02T11:02:00.000Z","path":"wiki/3-构建和链接静态库和动态库/","text":"3. 构建和链接静态库和动态库 项目中会有单个源文件构建的多个可执行文件的可能。项目中有多个源文件，通常分布在不同子目录中。这种实践有助于项目的源代码结构，而且支持模块化、代码重用和关注点分离。同时，这种分离可以简化并加速项目的重新编译。本示例中，我们将展示如何将源代码编译到库中，以及如何链接这些库。 具体实施 创建目标——静态库。库的名称和源码文件名相同，具体代码如下： 12345add_libraries(message STATIC Message.h Message.cpp) 创建 hello-world 可执行文件的目标部分不需要修改： 1add_executable(hello-world hello-world.cpp) 最后，将目标库链接到可执行目标： 1target_link_libraries(hello-world messgae) 编译 123456789101112131415161718$ mkdir build &amp;&amp; cd build$ cmake ..$ cmake --build .[ 50%] Built target messageScanning dependencies of target hello-world[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o[100%] Linking CXX executable hello-world[100%] Built target hello-world$ ls # 可以看到生成了 libmessage.a 静态库和可执行文件 hello-worldCMakeCache.txt CMakeFiles cmake_install.cmake hello-world libmessage.a Makefile$ ./hello-worldThis is my very nice message:hello, CMake World!This is my very nice message:Goodbye, CMake World! 工作原理 **add_library(message STATIC Message.h Message.cpp) **：生成必要的构建指令，将指定的源码编译到库中。 add_library 的第一个参数是目标名。整个 CMakeLists.txt 中，可使用相同的名称来引用库。 生成的库的实际名称将由 CMake 通过在前面添加前缀 lib 和适当的扩展名作为后缀来形成。 生成库是根据第二个参数( STATIC 或 SHARED )和操作系统确定的。 **target_link_libraries(hello-world message) **: 将库链接到可执行文件。 此命令还确保 hello-world 可执行文件可以正确地依赖于消息库。 因此，在消息库链接到 hello-world 可执行文件之前，需要完成消息库的构建。 编译成功后，构建目录包含 libmessage.a 一个静态库(在GNU/Linux上)和 hello-world 可执行文件。 add_library 其他参数 STATIC：用于创建静态库，即编译文件的打包存档，以便在链接其他目标时使用，例如：可执行文件。 SHARED：用于创建动态库，即可以动态链接，并在运行时加载的库。可以在 CMakeLists.txt 中使用 add_library(message SHARED Message.h Message.cpp) 从静态库切换到动态共享对象(DSO)。 OBJECT：可将给定 add_library 的列表中的源码编译到目标文件，不将它们归档到静态库中，也不能将它们链接到共享对象中。如果需要一次性创建静态库和动态库，那么使用对象库尤其有用。 MODULE：又为 DSO 组。与 SHARED 库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建运行时插件。 CMake 源代码 123456789101112131415161718cmake_minimum_required(VERSION 3.5)project(hello-world LANGUAGES CXX)# 创建目标——静态库。库的名称和源码文件名相同，具体代码如下：add_library(message # 生成静态库 STATIC # 包含库文件 Message.h Message.cpp)# 生成可执行文件add_executable(hello-world hello-world.cpp)# 链接目标库到可执行文件target_link_libraries(hello-world message)","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"2.切换生成器","date":"2023-03-02T10:52:00.000Z","path":"wiki/2-切换生成器/","text":"2.切换生成器显示构建器 （cmake –help）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859$ cmake --help...GeneratorsThe following generators are available on this platform (* marks default):* Visual Studio 16 2019 = Generates Visual Studio 2019 project files. Use -A option to specify architecture. Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 11 2012 [arch] = Generates Visual Studio 2012 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 10 2010 [arch] = Generates Visual Studio 2010 project files. Optional [arch] can be &quot;Win64&quot; or &quot;IA64&quot;. Visual Studio 9 2008 [arch] = Generates Visual Studio 2008 project files. Optional [arch] can be &quot;Win64&quot; or &quot;IA64&quot;. Borland Makefiles = Generates Borland makefiles. NMake Makefiles = Generates NMake makefiles. NMake Makefiles JOM = Generates JOM makefiles. MSYS Makefiles = Generates MSYS makefiles. MinGW Makefiles = Generates a make file for use with mingw32-make. Green Hills MULTI = Generates Green Hills MULTI files (experimental, work-in-progress). Unix Makefiles = Generates standard UNIX makefiles. Ninja = Generates build.ninja files. Ninja Multi-Config = Generates build-&lt;Config&gt;.ninja files. Watcom WMake = Generates Watcom WMake makefiles. CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files. CodeBlocks - NMake Makefiles = Generates CodeBlocks project files. CodeBlocks - NMake Makefiles JOM = Generates CodeBlocks project files. CodeBlocks - Ninja = Generates CodeBlocks project files. CodeBlocks - Unix Makefiles = Generates CodeBlocks project files. CodeLite - MinGW Makefiles = Generates CodeLite project files. CodeLite - NMake Makefiles = Generates CodeLite project files. CodeLite - Ninja = Generates CodeLite project files. CodeLite - Unix Makefiles = Generates CodeLite project files. Eclipse CDT4 - NMake Makefiles = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - MinGW Makefiles = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - Ninja = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files. Kate - MinGW Makefiles = Generates Kate project files. Kate - NMake Makefiles = Generates Kate project files. Kate - Ninja = Generates Kate project files. Kate - Unix Makefiles = Generates Kate project files. Sublime Text 2 - MinGW Makefiles = Generates Sublime Text 2 project files. Sublime Text 2 - NMake Makefiles = Generates Sublime Text 2 project files. Sublime Text 2 - Ninja = Generates Sublime Text 2 project files. Sublime Text 2 - Unix Makefiles = Generates Sublime Text 2 project files. 具体实施（用 -G 切换生成器） 首先，使用以下步骤配置项目: 123$ mkdir build$ cd build$ cmake -G &quot;CodeBlocks - Unix Makefiles&quot; .. 如何工作与前一个配置相比，每一步的输出没什么变化。每个生成器都有自己的文件集，所以编译步骤的输出和构建目录的内容是不同的：build.ninja 和 rules.ninja ：包含 Ninja 的所有的构建语句和构建规则。CMakeCache.txt ：CMake 会在这个文件中进行缓存，与生成器无关。CMakeFiles ：包含由 CMake 在配置期间生成的临时文件。cmake_install.cmake ：CMake 脚本处理安装规则，并在安装时使用。cmake –build . 将 ninja 命令封装在一个跨平台的接口中。 测试代码C示例： 12345678910// hello-world.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *say_hello() &#123; return &quot;Hello, CMake world!&quot;; &#125;int main() &#123; printf(&quot;%s\\n&quot;, say_hello()); return EXIT_SUCCESS;&#125; 12345678# CMakeLists.txt# 设置最低 cmake 版本cmake_minimum_required(VERSION 3.5 FATAL_ERROR)# 项目名称和语言project(recipe-01 LANGUAGES C)add_executable(hello-world hello-world.c) C++示例： 1234567891011//hello-world.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;std::string say_hello() &#123; return std::string(&quot;Hello, CMake world!&quot;); &#125;int main() &#123; std::cout &lt;&lt; say_hello() &lt;&lt; std::endl; return EXIT_SUCCESS;&#125; 12345678# CMakeLists.txt# 设置最低 cmake 版本cmake_minimum_required(VERSION 3.5 FATAL_ERROR)# 项目名称和语言project(recipe-01 LANGUAGES CXX)add_executable(hello-world hello-world.cpp)","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"1.将单个源文件编译为可执行文件","date":"2023-03-02T10:47:00.000Z","path":"wiki/1-将单个源文件编译为可执行文件/","text":"生成构建器123$ mkdir -p build$ cd build$ cmake .. 这里，我们创建了一个目录 build (生成构建器的位置)，进入 build 目录，并通过指定 CMakeLists.txt 的位置(本例中位于父目录中)来调用 CMake。 CMake语言不区分大小写，但是参数区分大小写。 CMake中，C++是默认的编程语言。不过，我们还是建议使用LANGUAGES 选项在 project 命令中显式地声明项目的语言。 可以使用以下命令行来实现相同的效果： 1234$ cmake -H. -Bbuild# 该命令是跨平台的，使用了-H 和-B 为 CLI 选项。# -H 表示当前目录中搜索根 CMakeLists.txt 文件。# -Bbuild 告诉 CMake 在一个名为 build 的目录中生成所有的文件。 构建项目12345678910111213# 在 build 文件夹下执行$ cmake --build .# Windows 输出如下$ cmake --build .用于 .NET Framework 的 Microsoft (R) 生成引擎版本 16.10.2+857e5a733版权所有(C) Microsoft Corporation。保留所有权利。 Checking Build System Building Custom Rule C:/Users/3D Objects/HelloCMake/CMakeLists.txt HelloCMake.cpp hello-cmake.vcxproj -&gt; C:\\Users\\3D Objects\\HelloCMake\\build\\Debug\\hello-cmake.exe Building Custom Rule C:/Users/3D Objects/HelloCMake/CMakeLists.txt","tags":[{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"}]},{"title":"8.重写项目历史","date":"2023-03-01T15:03:00.000Z","path":"wiki/8-重写项目历史/","text":"重写项目历史概述Git 的主要职责是保证你不会丢失提交的修改。但是，它同样被设计成让你完全掌控开发工作流。这包括了让你自定义你的项目历史，而这也创造了丢失提交的可能性。Git 提供了可以重写项目历史的命令，但也警告你这些命令可能会让你丢失内容。 这份教程讨论了重写提交快照的一些常见原因，并告诉你如何避免不好的影响。 git commit –amendgit commit --amend 命令是修复最新提交的便捷方式。它允许你将缓存的修改和之前的提交合并到一起，而不是提交一个全新的快照。它还可以用来简单地编辑上一次提交的信息而不改变快照。 但是，amend 不只是修改了最新的提交——它进行了一次替换。对于 Git 来说，这看上去像一个全新的提交，即上图中用星号表示的那一个。在公共仓库工作时一定要牢记这一点。 用法1git commit --amend 合并缓存的修改和上一次的提交，用新的快照替换上一个提交。缓存区没有文件时运行这个命令可以用来编辑上次提交的提交信息，而不会更改快照。 讨论仓促的提交在你日常开发过程中时常会发生。很容易就忘记了缓存一个文件或者弄错了提交信息的格式。--amend 标记是修复这些小意外的便捷方式。 不要修复公共提交在git reset这节中，我们说过永远不要重设和其他开发者共享的提交。对于修复也是一样：永远不要修复一个已经推送到公共仓库中的提交。 修复过的提交事实上是全新的提交，之前的提交会被移除出项目历史。这和重设公共快照的后果是一样的。如果你修复了其他开发者在之后继续开发的一个提交，看上去他们的工作基础从项目历史中消失了一样。对于在这上面的开发者来说这是很困惑的，而且很难恢复。 栗子下面这个🌰展示了 Git 开发工作流中的一个常见情形。我们编辑了一些希望在同一个快照中提交的文件，但我们忘记添加了其中的一个。修复错误只需要缓存那个文件并且用 --amend 标记提交： 1234567# 编辑 hello.py 和 main.pygit add hello.pygit commit# 意识到你忘记添加 main.py 的更改git add main.pygit commit --amend --no-edit 编辑器会弹出上一次提交的信息，加入 --no-edit 标记会修复提交但不修改提交信息。需要的话你可以修改，不然的话就像往常一样保存并关闭文件。完整的提交会替换之前不完整的提交，看上去就像我们在同一个快照中提交了 hello.py 和 main.py。 git rebase变基（rebase, 事实上这个名字十分诡异, 所以在大多数时候直接用英文术语）是将分支移到一个新的基提交的过程。过程一般如下所示： 从内容的角度来看，rebase 只不过是将分支从一个提交移到了另一个。但从内部机制来看，Git 是通过在选定的基上创建新提交来完成这件事的——它事实上重写了你的项目历史。理解这一点很重要，尽管分支看上去是一样的，但它包含了全新的提交。 用法1git rebase &lt;base&gt; 将当前分支 rebase 到 &lt;base&gt;，这里可以是任何类型的提交引用（ID、分支名、标签，或是 HEAD 的相对引用）。 讨论rebase 的主要目的是为了保持一个线性的项目历史。比如说，当你在 feature 分支工作时 master 分支取得了一些进展： 要将你的 feature 分支整合进 master 分支，你有两个选择：直接 merge，或者先 rebase 后 merge。前者会产生一个三路合并（3-way merge）和一个合并提交，而后者产生的是一个快速向前的合并以及完美的线性历史。下图展示了为什么 rebase 到 master 分支会促成一个快速向前的合并。 rebase 是将上游更改合并进本地仓库的通常方法。你每次想查看上游进展时，用 git merge 拉取上游更新会导致一个多余的合并提交。在另一方面，rebase 就好像是说「我想将我的更改建立在其他人的进展之上」。 不要 rebase 公共历史和我们讨论过的 git commit --amend 和 git reset 一样，你永远不应该 rebase 那些已经推送到公共仓库的提交。rebase 会用新的提交替换旧的提交，你的项目历史会像突然消失了一样。 栗子下面这个🌰同时使用 git rebase 和 git merge 来保持线性的项目历史。这是一个确认你的合并都是快速向前的方法。 1234# 开始新的功能分支git checkout -b new-feature master# 编辑文件git commit -a -m &quot;Start developing a feature&quot; 在 feature 分支开发了一半的时候，我们意识到项目中有一个安全漏洞: 12345678# 基于master分支创建一个快速修复分支git checkout -b hotfix master# 编辑文件git commit -a -m &quot;Fix security hole&quot;# 合并回mastergit checkout mastergit merge hotfixgit branch -d hotfix 将 hotfix 分支并回之后 master，我们有了一个分叉的项目历史。我们用 rebase 整合 feature 分支以获得线性的历史，而不是使用普通的 git merge。 12git checkout new-featuregit rebase master 它将 new-feature 分支移到了 master 分支的末端，现在我们可以在 master 上进行标准的快速向前合并了: 12git checkout mastergit merge new-feature git rebase -i用 -i 标记运行 git rebase 开始交互式 rebase。交互式 rebase 给你在过程中修改单个提交的机会，而不是盲目地将所有提交都移到新的基上。你可以移除、分割提交，更改提交的顺序。它就像是打了鸡血的 git commit --amend 一样。 用法1git rebase -i &lt;base&gt; 将当前分支 rebase 到 base，但使用可交互的形式。它会打开一个编辑器，你可以为每个将要 rebase 的提交输入命令（见后文）。这些命令决定了每个提交将会怎样被转移到新的基上去。你还可以对这些提交进行排序。 讨论交互式 rebase 给你了控制项目历史的完全掌控。它给了开发人员很大的自由，因为他们可以提交一个「混乱」的历史而只需专注于写代码，然后回去恢复干净。 大多数开发者喜欢在并入主代码库之前用交互式 rebase 来完善他们的 feature 分支。他们可以将不重要的提交合在一起，删除不需要的，确保所有东西在提交到「正式」的项目历史前都是整齐的。对其他人来说，这个功能的开发看上去是由一系列精心安排的提交组成的。 栗子下面这个🌰是 非交互式rebase 一节中🌰的可交互升级版本。 123456789101112131415# 开始新的功能分支git checkout -b new-feature master# 编辑文件git commit -a -m &quot;Start developing a feature&quot;# 编辑更多文件git commit -a -m &quot;Fix something from the previous commit&quot;# 直接在 master 上添加文件git checkout master# 编辑文件git commit -a -m &quot;Fix security hole&quot;# 开始交互式 rebasegit checkout new-featuregit rebase -i master 最后的那个命令会打开一个编辑器，包含 new-feature 的两个提交，和一些指示： 12pick 32618c4 Start developing a featurepick 62eed47 Fix something from the previous commit 你可以更改每个提交前的 pick 命令来决定在 rebase 时提交移动的方式。在我们的例子中，我们只需要用 squash 命令把两个提交并在一起就可以了： 12pick 32618c4 Start developing a featuresquash 62eed47 Fix something from the previous commit 保存并关闭编辑器以开始 rebase。另一个编辑器会打开，询问你合并后的快照的提交信息。在定义了提交信息之后，rebase 就完成了，你可以在 git log 输出中看到那个提交。整个过程可以用下图可视化： 注意缩并的提交和原来的两个提交的 ID 都不一样，告诉我们这确实是个新的提交。 最后，你可以执行一个快速向前的合并，来将完善的 feature 分支整合进主代码库： 12git checkout mastergit merge new-feature 交互式 rebase 强大的能力可以从整合后的 master 分支看出——额外的 62eed47 提交找不到了。对其他人来说，你就像是一个天才，用完美数量的提交完成了 new-feature。这就是交互式提交如何保持项目历史干净和合意。 git reflogGit 用引用日志这种机制来记录分支顶端的更新。它允许你回到那些不被任何分支或标签引用的更改。在重写历史后，引用日志包含了分支旧状态的信息，有需要的话你可以回到这个状态。 用法1git reflog 显示本地仓库的引用日志。 1git reflog --relative-date 用相对的日期显示引用日志。(如 2 周前）。 讨论每次当前的 HEAD 更新时（如切换分支、拉取新更改、重写历史或只是添加新的提交），引用日志都会添加一个新条目。 栗子为了理解 git reflog，我们来看一个🌰。 1230a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD~20254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to masterc10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2 上面的引用日志显示了 master 和 2.2 的 branch 之间的相互切换。还有对一个更老的提交的强制重设。最近的活动用 HEAD@&#123;0&#125; 标记在上方显示。 如果事实上你是不小心切换回去的，引用日志包含了你意外地丢掉两个提交之前 master 指向的提交 0254ea7。 1git reset --hard 0254ea7 使用 git reset，就有可能能将master变回之前的那个提交。它提供了一张安全网，以防历史发生意外更改。 务必记住，引用日志提供的安全网只对提交到本地仓库的更改有效，而且只有移动操作会被记录。 这篇文章参考于「git-recipes」","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"7.回滚错误的修改","date":"2023-03-01T14:55:00.000Z","path":"wiki/7-回滚错误的修改/","text":"回滚错误的修改这章教程提供了和项目旧版本打交道所需要的所有技巧。首先，你会知道如何浏览旧的提交，然后了解回滚项目历史中的公有提交和回滚本地机器上的私有更改之间的区别。 git checkout见上一章「6.检出历史提交」。 git revertgit revert 命令用来撤销一个已经提交的快照。但是，它是通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 新 提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。 用法1git revert &lt;commit&gt; 生成一个撤消了 &lt;commit&gt; 引入的修改的新提交，然后应用到当前分支。 讨论撤销（revert）应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 git revert，它帮你做了所有的事情。 撤销（revert）和重设（reset）对比理解这一点很重要。git revert 回滚了「单独一个提交」，它没有移除后面的提交，然后回到项目之前的状态。在 Git 中，后者实际上被称为 reset，而不是 revert。 撤销和重设相比有两个重要的优点。首先，它不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。至于为什么改变共享的历史是危险\b的，请参阅 git reset 一节。 其次，git revert 可以针对历史中任何一个提交，而 git reset 只能从当前提交向前回溯。比如，你想用 git reset 重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。不用说，这并不是一个优雅的回滚方案。 git reset如果说 git revert 是一个撤销更改安全的方式，你可以将 git reset 看做一个 危险 的方式。当你用 git reset 来重设更改时(提交不再被任何引用或引用日志所引用)，我们无法获得原来的样子——这个撤销是永远的。使用这个工具的时候务必要小心，因为这是少数几个可能会造成工作丢失的命令之一。 和 git checkout 一样，git reset 有很多种用法。它可以被用来移除提交快照，尽管它通常被用来撤销缓存区和工作目录的修改。不管是哪种情况，它应该只被用于 本地 修改——你永远不应该重设和其他开发者共享的快照。 用法1git reset &lt;file&gt; 从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。 1git reset 重设缓冲区，匹配最近的一次提交，但工作目录不变。它会取消 所有 文件的缓存，而不会覆盖任何修改，给你了一个重设缓存快照的机会。 1git reset --hard 重设缓冲区和工作目录，匹配最近的一次提交。除了取消缓存之外，--hard 标记告诉 Git 还要重写所有工作目录中的更改。换句话说：它清除了所有未提交的更改，所以在使用前确定你想扔掉你所有本地的开发。 1git reset &lt;commit&gt; 将当前分支的末端移到 &lt;commit&gt;，将缓存区重设到这个提交，但不改变工作目录。所有 &lt;commit&gt; 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。 1git reset --hard &lt;commit&gt; 将当前分支的末端移到 &lt;commit&gt;，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 &lt;commit&gt; 之后的所有提交。 讨论上面所有的调用都是用来移除仓库中的修改。没有 --hard 标记时 git reset 通过取消缓存或取消一系列的提交，然后重新构建提交来清理仓库。而加上 --hard 标记对于作了大死之后想要重头再来尤其方便。 撤销(revert)被设计为撤销 公开 的提交的安全方式，git reset被设计为重设 本地 更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。 不要重设公共历史当有 &lt;commit&gt; 之后的提交被推送到公共仓库后，你绝不应该使用 git reset。发布一个提交之后，你必须假设其他开发者会依赖于它。 移除一个其他团队成员在上面继续开发的提交在协作时会引发严重的问题。当他们试着和你的仓库同步时，他们会发现项目历史的一部分突然消失了。下面的序列展示了如果你尝试重设公共提交时会发生什么。origin/master 是你本地 master 分支对应的中央仓库中的分支。 一旦你在重设之后又增加了新的提交，Git 会认为你的本地历史已经和 origin/master 分叉了，同步你的仓库时的合并提交（merge commit）会使你的同事困惑。 重点是，确保你只对本地的修改使用 git reset，而不是公共更改。如果你需要修复一个公共提交，git revert 命令正是被设计来做这个的。 例子取消文件缓存git reset 命令在准备缓存快照时经常被用到。下面的例子假设你有两个文件，hello.py 和 main.py它们已经被加入了仓库中。 1234567891011121314151617# 编辑了hello.py和main.py# 缓存了目录下所有文件git add .# 意识到hello.py和main.py中的修改# 应该在不同的快照中提交# 取消main.py缓存git reset main.py# 只提交hello.pygit commit -m &quot;Make some changes to hello.py&quot;# 在另一份快照中提交main.pygit add main.pygit commit -m &quot;Edit main.py&quot; 如你所见，git reset 帮助你取消和这次提交无关的修改，让提交能够专注于某一特定的范围。 移除本地修改下面的这个栗子显示了一个更高端的用法。它展示了你作了大死之后应该如何扔掉那几个更新。 12345678910111213# 创建一个叫`foo.py`的新文件，增加代码# 提交到项目历史git add foo.pygit commit -m &quot;Start developing a crazy feature&quot;# 再次编辑`foo.py`，修改其他文件# 提交另一份快照git commit -a -m &quot;Continue my crazy feature&quot;# 决定废弃这个功能，并删除相关的更改git reset --hard HEAD~2 git reset HEAD~2 命令将当前分支向前倒退两个提交，相当于在项目历史中移除刚创建的这两个提交。记住，这种重设只能用在 非公开 的提交中。绝不要在将提交推送到共享仓库之后执行上面的操作。 git cleangit clean 命令将未跟踪的文件从你的工作目录中移除。它只是提供了一条捷径，因为用 git status 查看哪些文件还未跟踪然后手动移除它们也很方便。和一般的 rm 命令一样，git clean 是无法撤消的，所以在删除未跟踪的文件之前想清楚，你是否真的要这么做。 git clean 命令经常和 git reset --hard 一起使用。记住，reset 只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。 用法1git clean -n 执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。 1git clean -f 移除当前目录下未被跟踪的文件。-f（强制）标记是必需的，除非 clean.requireForce 配置项被设为了 false（默认为 true）。它 不会 删除 .gitignore 中指定的未跟踪的文件。 1git clean -f &lt;path&gt; 移除未跟踪的文件，但限制在某个路径下。 1git clean -df 移除未跟踪的文件，以及目录。 1git clean -xf 移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。 讨论如果你在本地仓库中作死之后想要毁尸灭迹，git reset --hard 和 git clean -f 是你最好的选择。运行这两个命令使工作目录和最近的提交相匹配，让你在干净的状态下继续工作。 git clean 命令对于 build 后清理工作目录十分有用。比如，它可以轻易地删除 C 编译器生成的 .o 和 .exe 二进制文件。这通常是打包发布前需要的一步。-x 命令在这种情况下特别方便。 请牢记，和 git reset 一样， git clean 是仅有的几个可以永久删除提交的命令之一，所以要小心使用。事实上，它太容易丢掉重要的修改了，以至于 Git 厂商 强制 你用 -f 标志来进行最基本的操作。这可以避免你用一个 git clean 就不小心删除了所有东西。 例子下面的栗子清除了工作目录中的所有更改，包括新建还没加入缓存的文件。它假设你已经提交了一些快照，准备开始一些新的实验。 123456789# 编辑了一些文件# 新增了一些文件# 『糟糕』# 将跟踪的文件回滚回去git reset --hard# 移除未跟踪的文件git clean -df 在执行了 reset/clean 的流程之后，工作目录和缓存区和最近一次提交看上去一模一样，而 git status会认为这是一个干净的工作目录。你可以重新来过了。 注意，不像 git reset 的第二个栗子，新的文件没有被加入到仓库中。因此，它们不会受到 git reset --hard 的影响，需要 git clean 来删除它们。 这是一篇在原文（BY atlassian）基础上演绎的译文。","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"6.检出历史提交","date":"2023-03-01T14:53:00.000Z","path":"wiki/6-检出历史提交/","text":"检出历史提交git checkoutgit checkout 这个命令有三个不同的作用：检出文件、检出提交和检出分支。在这一章中，我们只关心前两种用法。 检出提交会使工作目录和这个提交完全匹配。你可以用它来查看项目之前的状态，而不改变当前的状态。检出文件使你能够查看某个特定文件的旧版本，而工作目录中剩下的文件不变。 用法1git checkout master 回到 master 分支。分支会在下一节中讲到，而现在，你只需要将它视为回到项目「当前」状态的一种方式。 1git checkout &lt;commit&gt; &lt;file&gt; 查看文件之前的版本。它将工作目录中的 &lt;file&gt; 文件变成 &lt;commit&gt; 中那个文件的拷贝，并将它加入缓存区。 1git checkout &lt;commit&gt; 更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 &lt;commit&gt; 参数。这会使你处在分离 HEAD 的状态。 讨论版本控制系统背后的思想就是「安全」地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库。当你建立了项目历史之后，git checkout 是一种便捷的方式，来将保存的快照「加载」到你的开发机器上去。 检出之前的提交是一个只读操作。在查看旧版本的时候绝不会损坏你的仓库。你项目「当前」的状态在 master 上不会变化。在开发的正常阶段，HEAD 一般指向 master 或是其他的本地分支，但当你检出之前提交的时候，HEAD 就不再指向一个分支了——它直接指向一个提交。这被称为「分离 HEAD」状态 ，可以用下图可视化： 在另一方面，检出旧文件不影响你仓库的当前状态。你可以在新的快照中像其他文件一样重新提交旧版本。所以，在效果上，git checkout 的这个用法可以用来将单个文件回滚到旧版本 。 例子查看之前的版本这个栗子假定你开始了一个疯狂的实验，但你不确定你是否想要保留它。为了帮助你决定，你想看一看你开始实验之前的项目状态。首先，你需要找到你想要看的那个版本的 ID。 1git log --oneline 假设你的项目历史看上去和下面一样： 12345b7119f2 继续做些丧心病狂的事872fa7e 做些丧心病狂的事a1e8fb5 对 hello.py 做了一些修改435b61d 创建 hello.py9773e52 初始导入 你可以这样使用 git checkout 来查看「对 hello.py 做了一些修改」这个提交： 1git checkout a1e8fb5 这让你的工作目录和 a1e8fb5 提交所处的状态完全一致。你可以查看文件，编译项目，运行测试，甚至编辑文件而不需要考虑是否会影响项目的当前状态。你所做的一切 都不会 被保存到仓库中。为了继续开发，你需要回到你项目的「当前」状态： 1git checkout master 这里假定了你默认在 master 分支上开发，我们会在以后的分支模型中详细讨论。 一旦你回到 master 分支之后，你可以使用 git revert 或 git reset 来回滚任何不想要的更改。 检出文件如果你只对某个文件感兴趣，你也可以用 git checkout 来获取它的一个旧版本。比如说，如果你只想从之前的提交中查看 hello.py 文件，你可以使用下面的命令： 1git checkout a1e8fb5 hello.py 记住，和检出提交不同，这里 确实 会影响你项目的当前状态。旧的文件版本会显示为「需要提交的更改」，允许你回滚到文件之前的版本。如果你不想保留旧的版本，你可以用下面的命令检出到最近的版本： 1git checkout HEAD hello.py 这篇教程来源于「git-recipes」","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"5.查看仓库状态","date":"2023-03-01T14:52:00.000Z","path":"wiki/5-查看仓库状态/","text":"检查仓库状态git statusgit status 命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被 Git 追踪。status 的输出 不会 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用 git log 命令。 用法1git status 列出已缓存、未缓存、未追踪的文件。 讨论git status 是一个相对简单的命令。 它告诉你 git add 和 git commit 的进展。status 信息还包括了添加缓存和移除缓存的相关指令。样例输出显示了三类主要的 git status 输出： 12345678910111213141516# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##modified: hello.py## Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##modified: main.py## Untracked files:# (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)##hello.pyc 忽略文件未追踪的文件通常有两类。它们要么是项目新增但还未提交的文件，要么是像 .pyc、.obj、.exe 等编译后的二进制文件。显然前者应该出现在 git status 的输出中，而后者会让我们困惑究竟发生了什么。 因此，Git 允许你完全忽略这些文件，只需要将路径放在一个特定的 .gitignore 文件中。所有想要忽略的文件应该分别写在单独一行，* 字符用作通配符。比如，将下面这行加入项目根目录的.gitignore文件可以避免编译后的Python模块出现在git status中： 1*.pyc 例子在提交更改前检查仓库状态是一个良好的实践，这样你就不会不小心提交什么奇怪的东西。这个例子显示了缓存和提交快照前后的仓库状态： 123456789# Edit hello.pygit status# hello.py is listed under &quot;Changes not staged for commit&quot;git add hello.pygit status# hello.py is listed under &quot;Changes to be committed&quot;git commitgit status# nothing to commit (working directory clean) 第一个 status 的输出显示文件还未缓存。git add 操作会影响第二个 git status，最后的 status 输出告诉你已经没有可以提交的东西了——工作目录和最近的提交一致。一些 Git 命令（比如 git merge）需要工作目录整洁，以免意外覆盖更改。 git loggit log 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。git status 允许你查看工作目录和缓存区，而 git log 只作用于提交的项目历史。 log 输出可以有很多种自定义的方式，从简单地筛选提交，到用完全自定义的格式显示。其中一些最常用的 git log 配置如下所示。 用法1git log 使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用 空格键 来滚动，按 q 退出。 1git log -n &lt;limit&gt; 用 &lt;limit&gt; 限制提交的数量。比如 git log -n 3 只会显示 3 个提交。 1git log --oneline 将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。 1git log --stat 除了 git log 信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。 1git log -p 显示代表每个提交的一堆信息。显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。 1git log --author=&quot;&lt;pattern&gt;&quot; 搜索特定作者的提交。&lt;pattern&gt; 可以是字符串或正则表达式。 1git log --grep=&quot;&lt;pattern&gt;&quot; 搜索提交信息匹配特定 &lt;pattern&gt; 的提交。&lt;pattern&gt; 可以是字符串或正则表达式。 1git log &lt;since&gt;..&lt;until&gt; 只显示发生在 &lt;since&gt; 和 &lt;until&gt; 之间的提交。两个参数可以是提交 ID、分支名、HEAD 或是任何一种引用。 1git log &lt;file&gt; 只显示包含特定文件的提交。查找特定文件的历史这样做会很方便。 1git log --graph --decorate --oneline 还有一些有用的选项。--graph 标记会绘制一幅字符组成的图形，左边是提交，右边是提交信息。--decorate 标记会加上提交所在的分支名称和标签。--oneline 标记将提交信息显示在同一行，一目了然。 讨论git log 命令是 Git 查看项目历史的基本工具。当你要寻找项目特定的一个版本或者弄明白合并功能分支时引入了哪些变化，你就会用到这个命令。 12commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7Author: John Smith 大多数时候都很简单直接。但是，第一行需要解释下。commit 后面 40 个字的字符串是提交内容的 SHA-1 校验总和（checksum）。它有两个作用。一是保证提交的正确性——如果它被损坏了，提交会生成一个不同的校验总和。第二，它是提交唯一的标识 ID。 这个 ID 可以用于 git log 这样的命令中来引用具体的提交。比如，git log 3157e..5ab91 会显示所有ID在 3157e 和 5ab91 之间的提交。除了校验总和之外，分支名、HEAD 关键字也是常用的引用提交的方法。HEAD 总是指向当前的提交，无论是分支还是特定提交也好。 字符用于表示提交的父节点的相对引用。比如，`3157e1指向3157e 前一个提交,HEAD~3` 是当前提交的回溯3个节点的提交。 所有这些标识方法的背后都是为了让你对特定提交进行操作。git log 命令一般是这些交互的起点，因为它让你找到你想要的提交。 例子用法 一节提供了 git log 很多的栗子，但请记住，你可以将很多选项用在同一个命令中： 1git log --author=&quot;John Smith&quot; -p hello.py 这个命令会显示 John Smith 作者对 hello.py 文件所做的所有更改的差异比较（diff）。 ..句法是比较分支很有用的工具。下面的栗子显示了在 some-feature 分支而不在 master 分支的所有提交的概览。 1git log --oneline master..some-feature 这篇教程来源于「git-recipes」","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"4.保存更改","date":"2023-03-01T14:50:00.000Z","path":"wiki/4-保存更改/","text":"git add / git commit / git diff / git stash / .gitignore “保存”这个概念在 Git 等版本控制系统和 Word 等文本编辑应用中不太一样。传统软件里的“保存”在 Git 里被叫做“提交”（commit）。 我们常说的的保存可以理解成在文件系统中覆盖一个已有的文件或者创建一个新的文件。而在 Git 中，提交这个操作作用于若干个文件和目录。 在 Git 和 SVN 里保存更改也不一样。SVN 提交或检入（check-in）将会推送到远端的中央服务器。也就是说 SVN 的提交需要联网才能完全“保存”项目更改。Git 提交可以在本地完成，然后再使用git push -u origin master命令推送到远端服务器。这两种方法的区别体现了两种架构设计的本质区别。Git 是一个分布式的应用，而 SVN 是一个中心化的应用。分布式应用一般来说更可靠，因为它们不存在中央服务器这样的单点故障。 git add、git status和git commit这三个命令通常一起使用，将 Git 项目当前的状态保存成一份快照。 Git 还有另一个保存机制：“储藏”（stash）。储藏是一个临时的储存区域，保存还没准备好提交的更改。储藏操作作用于工作目录，三个文件树中的第一棵。它有很多用法，访问 git stash 页面了解更多。 Git 仓库可以通过设置忽略一些文件或目录。Git 将不会保存这些文件的任何更改。Git 有多种方式管理忽略文件列表。访问 git ignore 页面了解更多 Git 忽略文件设置。 git addgit add 命令将工作目录中的变化添加到暂存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，git add 不会实质上地影响你的仓库——在你运行 git commit 前更改都还没有真正被记录。 使用这些命令的同时，你还需要 git status 来查看工作目录和暂存区的状态。 用法1git add &lt;file&gt; 将 &lt;file&gt; 中的更改加入下次提交的缓存。 1git add &lt;directory&gt; 将 &lt;directory&gt; 下的更改加入下次提交的缓存。 1git add -i 开始交互式的缓存，你可以选择文件的一部分加入到下次提交缓存。它会向你展示一堆更改，等待你输入一个命令。y 将这块更改加入缓存，n 忽略这块更改，s 将它分割成更小的块，e 手动编辑这块更改，以及 q 退出。 讨论git add 和 git commit 这两个命令组成了最基本的 Git 工作流。每一个 Git 用户都需要理解这两个命令，不管他们团队的协作模型是如何的。我有一千种方式可以将项目版本记录在仓库的历史中。 在一个只有编辑、缓存、提交这样基本流程的项目上开发。首先，你要在工作目录中编辑你的文件。当你准备备份项目的当前状态时，你通过 git add 来缓存更改。当你对缓存的快照满意之后，你通过 git commit 将它提交到你的项目历史中去。 git add 命令不能和 svn add 混在一起理解，后者将文件添加到仓库中。而 git add 发生于更抽象的 更改 层面。也就是说，git add 在每次你修改一个文件时都需要被调用，而 svn add 只需要每个文件调用一次。这听上去很多余，但这样的工作流使得一个项目更容易组织。 缓存区缓存区是 Git 更为独特的地方之一，如果你是从 SVN（甚至是 Mercurial）迁移而来，那你可得花点时间理解了。你可以简单地把它想成是工作目录和项目历史之间的缓冲区。 缓存允许你在实际提交到项目历史之前，将相关的更改组合成一份高度专注的快照，而不是将你上次提交以后产生的所有更改一并提交。也就是说你可以更改各种不相关的文件，然后回过去将它们按逻辑切分，将相关的更改添加到缓存，一份一份提交。在任何修改控制系统中，很重要的一点是提交必须是原子性的，以便于追踪 bug，并用最小的代价回滚更改。 例子当你开始新项目的时候，git add 和 svn import 类似。为了创建当前目录的初始提交，使用下面两个命令： 12git add .git commit 当你项目设置好之后，新的文件可以通过路径传递给 git add 来添加： 12git add hello.pygit commit 上面的命令同样可以用于记录已有文件的更改。重复一次，Git 不会区分缓存的更改来自新文件，还是仓库中已有的文件。 git commitgit commit命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 git add 一样，这是最重要的 Git 命令之一。 尽管和它和 svn commit 名字一样，但实际上它们毫无关联。快照被提交到本地仓库，不会和其他 Git 仓库有任何交互。 用法1git commit 提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。 1git commit -m &quot;&lt;message&gt;&quot; 提交已经缓存的快照。但将 &lt;message&gt; 作为提交信息，而不是运行文本编辑器。 1git commit -a 提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 git add 添加过的文件）。 讨论快照总是提交到 本地 仓库。这一点和 SVN 截然不同，后者的工作拷贝提交到中央仓库。而 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。 这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这对于 SVN 风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。 记录快照，而不是记录差异SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 变化 ，而 Git 的版本控制模型基于 快照 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 完整内容 。 这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。 Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。 例子下面这个栗子假设你编辑了 hello.py 文件的一些内容，并且准备好将它提交到项目历史。首先，你需要用 git add 缓存文件，然后提交缓存的快照。 12git add hello.pygit commit 它会打开一个文件编辑器（可以通过 git config 设置) 询问提交信息，同时列出将被提交的文件。 1234567# Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##modified: hello.py Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如： 1234Change the message displayed by hello.py- Update the sayHello() function to output the user&#x27;s name- Change the sayGoodbye() function to a friendlier message 注意，很多开发者倾向于在提交信息中使用一般现在时态。这样看起来更像是对仓库进行的操作，让很多改写历史的操作更加符合直觉。 这篇教程来源于「git-recipes」","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"3.创建代码仓库","date":"2023-03-01T14:48:00.000Z","path":"wiki/3-创建代码仓库/","text":"创建代码仓库这一章简要地带你了解一些最重要的 Git 命令。在这节中，我会向你介绍开始一个新的版本控制项目需要的所有工具，后面的几节包含了你每天都会用到的Git操作。 在这节之后，你应该能够创建一个新的 Git 仓库，缓存你的项目以免丢失，以及查看你项目的历史。 git initgit init 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。大多数Git命令在未初始化的仓库中都是无法使用的，所以这就是你运行新项目的第一个命令了。 运行 git init 命令会在你项目的根目录下创建一个新的 .git 目录，其中包含了你项目必需的所有元数据。除了 .git 目录之外，已经存在的项目不会被改变（就像 SVN 一样，Git 不强制每个子目录中都有一个 .git 目录）。 用法1git init 将当前的目录转换成一个 Git 仓库。它在当前的目录下增加了一个 .git 目录，于是就可以开始记录项目版本了。 1git init &lt;directory&gt; 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。 1git init --bare &lt;directory&gt; 初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 --bare 标记创建（见下面的讨论）。一般来说，用 —bare 标记初始化的仓库以 .git 结尾。比如，一个叫my-project的仓库，它的空版本应该保存在 my-project.git 目录下。 讨论和 SVN 相比，git init 命令是一个创建新的版本控制项目非常简单的途径。Git 不需要你创建仓库，导入文件，检查正在修改的拷贝。你只需要 cd 到你的项目目录下，运行 git init，你就有了一个功能强大的 Git 仓库。 但是，对大多数项目来说，git init 只需要在创建中央仓库时执行一次——开发者通常不会使用 git init 来创建他们的本地仓库。他们往往使用 git clone 来将已存在的仓库拷贝到他们的机器中去。 裸仓库-—bare 标记创建了一个没有工作目录的仓库，这样我们在仓库中更改文件并且提交了。中央仓库应该总是创建成裸仓库，因为向非裸仓库推送分支有可能会覆盖已有的代码变动。将-—bare看成是用来将仓库标记为储存设施，而不是一个开发环境。也就是说，对于所有的 Git 工作流，中央仓库是裸仓库，开发者的本地仓库是非裸仓库。 例子因为 git clone 创建项目的本地拷贝更为方便，git init 最常见的使用情景就是用于创建中央仓库： 12345ssh &lt;user&gt;@&lt;host&gt;cd path/above/repogit init --bare my-project.git 首先，你用SSH连入存放中央仓库的服务器。然后，来到任何你想存放项目的地方，最后，使用 -—bare 标记来创建一个中央存储仓库。开发者会将 my-project.git 克隆到本地的开发环境中。 git clonegit clone 命令拷贝整个 Git 仓库。这个命令就像 svn checkout 一样，除了「工作副本」是一个完备的Git仓库——它包含自己的历史，管理自己的文件，以及环境和原仓库完全隔离。 为了方便起见，clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。 用法1git clone &lt;repo&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。 1git clone &lt;repo&gt; &lt;directory&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录。 讨论如果项目在远程仓库已经设置完毕，git clone 是用户获取开发副本最常见的方式。和 git init相似，clone 通常也是一次性的操作——只要开发者获得了一份工作副本，所有版本控制操作和协作管理都是在本地仓库中完成的。 仓库间协作这一点很重要，你要理解 Git 中「工作副本」的概念和 SVN 仓库 check out 下来的「工作副本」是很不一样的。和 SVN 不同的是，Git 不会区分工作副本和中央仓库——它们都是功能完备的 Git 仓库。 这就使得 Git 的协作和 SVN 截然不同。SVN 依赖于中央仓库和工作副本之间的关系，而 Git 协作模型是基于仓库和仓库之间的交互的。相对于 SVN 的提交流程，你可以在 Git 仓库之间 push 或 pull 提交。 当然，你也完全可以给予某个特定的仓库一些特殊的含义。比如，指定某个 Git 仓库为中央仓库，你就可以用 Git 进行中央化的工作流。重点是，这是通过约定实现的，而不是写死在版本控制系统本身。 例子下面这个例子演示用 SSH 用户名 john 连接到 example.com，获取远程服务器上中央仓库的本地副本： 12345git clone ssh://john@example.com/path/to/my-project.gitcd my-project# 开始工作 第一行命令在本地机器的 my-project 目录下初始化了一个新的 Git 仓库，并且导入了中央仓库中的文件。接下来，你 cd 到项目目录，开始编辑文件、缓存提交、和其它仓库交互。同时注意 .git 拓展名克隆时会被去除。它表明了本地副本的非裸状态。 1git config git config 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。 用法1git config user.name &lt;name&gt; 定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 --global 标记设置当前用户的配置项。 1git config --global user.name &lt;name&gt; 定义当前用户所有提交使用的作者姓名。 1git config --global user.email &lt;email&gt; 定义当前用户所有提交使用的作者邮箱。 1git config --global alias.&lt;alias-name&gt; &lt;git-command&gt; 为Git命令创建一个快捷方式（别名）。 1git config --system core.editor &lt;editor&gt; 定义当前机器所有用户使用命令时用到的文本编辑器，如 git commit。&lt;editor&gt; 参数用编辑器的启动命令（如 vi）替代。 1git config --global --edit 用文本编辑器打开全局配置文件，手动编辑。 讨论所有配置项都储存在纯文本文件中，所以 git config 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 --global 标记。 Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。 /.git/config – 特定仓库的设置。 ~/.gitconfig – 特定用户的设置。这也是 --global 标记的设置项存放的位置。 $(prefix)/etc/gitconfig – 系统层面的设置。 当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些： 123456789101112131415161718192021[user]name = John Smithemail = john@example.com[alias]st = statusco = checkoutbr = branchup = rebaseci = commit[core]editor = vim 你可以用 git config 手动编辑这些值。 例子你在安装 Git 之后想要做的第一件事是告诉它你的名字和邮箱，个性化一些默认设置。一般初始的设置过程看上去是这样的： 123456789101112131415161718192021# 告诉Git你是谁git config --global user.name &quot;John Smith&quot;git config --global user.email john@example.com# 选择你喜欢的文本编辑器git config --global core.editor vim# 添加一些快捷方式(别名)git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.up rebasegit config --global alias.ci commit 它会生成上一节中所说的 ~/.gitconfig 文件。 这篇教程来源于「git-recipes」","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"2.git安装与初体验","date":"2023-03-01T14:45:00.000Z","path":"wiki/2-git安装与初体验/","text":"Git 简易指南这节是完全面向入门者的，我假设你从零开始创建一个项目并且想用 Git 来进行版本控制，因此本文会避开分支这些相对复杂的概念。 在这节中，我会介绍如何在你的个人项目中使用 Git，我们会讨论 Git 最基本的操作——如何初始化你的项目，如何管理新的或者已有的文件，如何在远端仓库中储存你的代码。 安装 Git Mac 用户：Xcode Command Line Tools 自带 Git（xcode-select --install） Linux 用户：sudo apt-get install git Windows 用户：下载 Git SCM 1- 对于 Windows 用户，安装后如果希望在全局的 cmd 中使用 Git，需要把 git.exe 加入 PATH 环境变量中，或在 Git Bash 中使用 Git。 检出仓库执行如下命令以创建一个本地仓库的克隆版本： git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： git clone username@host:/path/to/repository （通过 SSH） 或者： git clone https:/path/to/repository.git （通过 https） 比如说 git clone https://github.com/geeeeeeeeek/git-recipes.git 可以将 git 教程 clone 到你指定的目录。 创建新仓库创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。 下面每一步中，你都可以通过 git status 来查看你的git仓库状态。 工作流你的本地仓库由 Git 维护的三棵「树」组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。 事实上，第三个阶段是 commit history 的图。HEAD 一般是指向最新一次 commit 的引用。现在暂时不必究其细节。 添加与提交你可以计划改动（把它们添加到缓存区），使用如下命令： 12git add &lt; filename &gt;git add * 这是 Git 基本工作流程的第一步。使用如下命令以实际提交改动： 1git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 在开发时，良好的习惯是根据工作进度及时 commit，并务必注意附上有意义的 commit message。创建完项目目录后，第一次提交的 commit message 一般为「Initial commit」。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库： 1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： 1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 这里 origin 是 &lt;server&gt; 的别名，取什么名字都可以，你也可以在 push 时将 &lt;jserver&gt; 替换为 origin。但为了以后 push 方便，我们第一次一般都会先 remote add。 如果你还没有 Git 仓库，可以在 Github 等代码托管平台上创建一个空（不要自动生成 README.md）的仓库，然后将代码 push 到远端仓库。 至此，你应该可以顺利地提交你的项目了。在下一节中，我们将涉及更多的命令，来完成更有用的操作。比如从远端的仓库拉取更新并且合并到你的本地，如何通过分支多人协作，如何处理不同分支的冲突等等。 本教程来源于「Git Recipes」。","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"1.什么是 Git","date":"2023-03-01T14:42:00.000Z","path":"wiki/1-什么是-Git/","text":"什么是 Git到目前为止，Git 是世界上使用最为广泛的现代化版本控制系统。Git 最初由 Linux 系统内核的作者 Linus Torvalds 在 2005 年开始开发，目前已经是一个持续维护的成熟开源项目。如今，大量软件项目依赖 Git 进行版本管理，其中既有开源软件，也有商业软件。Git 在很多操作系统和集成开发环境（IDE）上都表现良好。绝大多数软件开发者或多或少都使用过 Git。 Git 是分布式版本管理（DVCS）的一种。CVS 和 Subversion（SVN）等集中式的版本管理软件将完整的版本历史存放在同一个地方。而在 Git 中，每个开发者的代码仓库都包含了所有变更历史。 除了分布式之外，Git 在设计之初也考虑了性能、安全性和灵活性。 高性能Git 的底层性能相较于其他版本管理软件有强大的优势。提交修改、创建分支、合并分支和比较版本都针对性能进行了优化。Git 中实现的算法利用了现实中代码树的特点以及它们被修改和访问的常见模式。 不同于某些版本管理软件，Git 在决定文件树的储存和版本历史时，不会被文件名的变化所愚弄——Git 关注的是文件的内容本身。毕竟，代码文件经常会被重命名、拆分和重新编排。Git 仓库中的文件对象通过差分编码（delta encoding，仅保存代码修改的差分）和压缩技术储存，并且直接保存文件夹中的内容和版本控制元数据。 分布式架构也给 Git 带来了巨大的性能优势。 比如说，有一名开发成员 Alice 修改了代码，添加了一些准备在 2.0 版本中发布的功能，然后提交了这些修改及其描述。随后，她又编写并提交了另一个新功能。很自然地，这两次修改是版本历史中两份独立的工作。Alice 又切换到了 1.3 版本的分支，修复了一个只影响这个旧版本的 bug。这次修复的目的是为了让团队在 2.0 版本还没有完成之前，发布一个 1.3.1 版本来解决旧版本中的一些 bug。Alice 可以立刻回到 2.0 版本分支，继续新功能开发。这一切都不需要网络连接，非常快速可靠，甚至可以在飞机中完成。当她准备好将这些单独提交的更改发送到远程仓库时，她只需要一个“推送”（push）命令。 安全Git 设计时就把托管代码的完好性作为重中之重。文件内容以及文件、目录、版本、标签和提交的关联，都通过安全的加密哈希校验算法（SHA1）保护。这可以避免代码和修改历史被不小心或者恶意改变，并且保证修改历史完全可追迹。 你可以相信在 Git 中源代码的修改历史是真实可靠的。 有一些版本管理软件无法防止版本历史之后被篡改。这对于任何依赖软件开发的团队来说都是严重的安全漏洞。 灵活Git 的关键设计目标之一就是灵活。Git 在很多方面都展现出了其灵活性：支持多种非线性的工作流，对不同规模的项目来说都很高效，并且兼容多个操作系统和协议。 Git 在设计时最重要的功能便是分支和标签（不同于 SVN），因此所有影响分支和标签的操作也都会被保存到修改历史中。不是所有的版本管理软件关注的都是这个层面的版本追踪。 使用 Git 进行版本管理Git 对于绝大多数软件开发团队来说都是最好的选择。虽然每个团队都需要考虑自身的情况，但我们依然可以列举一些 Git 比其他版本控制系统更好的理由： Git 很好用Git 兼具大多数团队和个人开发者需要的功能、性能，安全性和灵活性。我们已经具体讨论过了这些特点。对很多团队来说，它们发现 Git 在这几点上都表现的更优秀。 Git 已经成为了事实上的行业标准Git 使用最广泛的版本管理软件。这使得 Git 在以下这些方面具有极大的吸引力。在 Atlassian（作者所在的公司），大多数代码都是通过 Git 管理的。 大量开发者都有过 Git 的使用经历，很大一部分大学毕业生甚至只用过 Git 进行版本管理。虽然迁移到 Git 的过程中或许会经历比较陡峭的学习曲线，但是大多数员工以及未来的员工都已经具备了使用 Git 的基本技能，这意味着他们不需要额外的培训。 除了拥有大量使用者之外，Git 的普及还意味着很多第三方的服务和 IDE 都已经集成了 Git。比如我们的 DVCS 桌面客户端 Source Tree、项目开发管理软件 JIRA 和代码托管服务 Bitbucket。 如果你是一个想要积累软件开发工具使用技能的新人，Git 毫无疑问是你在版本管理方面的第一选择。 Git 是一个高质量的开源项目Git 本身是一个经历多年良好支持和管理的开源软件项目。Git 的维护者很好地平衡了长远的用户需求，和改进可用性和功能性的例行更新。这个开源项目的质量久经考验，无数企业都极度依赖于此。 Git 还拥有良好的社区支持和庞大的用户群体。你可以找到各种深入浅出的学习资料，包括书籍，教程，以及专题网站。你也可以找到相关的播客节目和视频教程。 开源降低了业余开发者的成本，因为他们不需要花一分钱来使用 Git。对于开源项目来说，Git 无疑是 SVN 和 CVS 等上一代流行版本管理软件的接班人。 对 Git 的批评对于 Git 的一个常见批评是它学起来不那么容易。Git 中的某些术语对于新手或者是使用其他系统的朋友可能会比较陌生。比如说，revert 这个命令在 Git、SVN、CVS 中具有不同的含义。不过，Git 向用户提供了非常强大的功能。学习掌握这些功能也许会花一些时间，但是一旦你学会了这些技能，它们会帮助你大大提高团队的开发效率。 对于曾经使用非分布式版本管理的团队来说，他们可能不想放弃中央服务器。不过，虽然 Git 被设计成分布式的架构，你依然可以建立一个“官方”的代码库来存放所有的修改。使用 Git 时，由于所有的开发者都拥有完整的代码库拷贝，所以他们的工作不会被中央服务器的状态和性能所影响。即使遇到故障，他们依然可以查看完整的项目历史。得益于 Git 的灵活性和分布式特点，你可以在保持原有工作方式的同时还可以得到 Git 带来的额外好处，而你以前甚至不会意识到这些好处。 现在你已经明白了什么是版本管理，什么是 Git 以及为什么要使用 Git ，你可以选择继续阅读下一节，了解 Git 在整个组织层面带来的好处。 本教程来源于「Git Recipes」。","tags":[{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"}]},{"title":"八.结构体","date":"2023-03-01T11:33:00.000Z","path":"wiki/八-结构体/","text":"8 结构体8.1 结构体基本概念结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型 8.2 结构体定义和使用语法：struct 结构体名 &#123; 结构体成员列表 &#125;； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： 1234567891011121314151617181920212223242526272829303132333435363738//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;stu3; //结构体变量创建方式3 int main() &#123; //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = &quot;张三&quot;; stu1.age = 18; stu1.score = 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = &#123; &quot;李四&quot;,19,60 &#125;; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = &quot;王五&quot;; stu3.age = 18; stu3.score = 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法： struct 结构体名 数组名[元素个数] = &#123; &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125; 示例： 12345678910111213141516171819202122232425262728//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;int main() &#123; //结构体数组 struct student arr[3]= &#123; &#123;&quot;张三&quot;,18,80 &#125;, &#123;&quot;李四&quot;,19,60 &#125;, &#123;&quot;王五&quot;,20,70 &#125; &#125;; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 8.4 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt; 可以通过结构体指针访问结构体属性 示例： 123456789101112131415161718192021222324//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;int main() &#123; struct student stu = &#123; &quot;张三&quot;,18,100, &#125;; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： 123456789101112131415161718192021222324252627282930313233343536373839//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//教师结构体定义struct teacher&#123; //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生&#125;;int main() &#123; struct teacher t1; t1.id = 10000; t1.name = &quot;老王&quot;; t1.age = 40; t1.stu.name = &quot;张三&quot;; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//值传递void printStudent(student stu )&#123; stu.age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;&#125;//地址传递void printStudent2(student *stu)&#123; stu-&gt;age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu = &#123; &quot;张三&quot;,18,100&#125;; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景作用：用const来防止误操作 示例： 123456789101112131415161718192021222324252627//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作&#123; //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu = &#123; &quot;张三&quot;,18,100 &#125;; printStudent(&amp;stu); system(&quot;pause&quot;); return 0;&#125; 8.8 结构体案例8.8.1 案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Student&#123; string name; int score;&#125;;struct Teacher&#123; string name; Student sArray[5];&#125;;void allocateSpace(Teacher tArray[] , int len)&#123; string tName = &quot;教师&quot;; string sName = &quot;学生&quot;; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; len; i++) &#123; tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) &#123; tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; &#125; &#125;&#125;void printTeachers(Teacher tArray[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) &#123; cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(&quot;pause&quot;); return 0;&#125; 8.8.2 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： 12345&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;, 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//英雄结构体struct hero&#123; string name; int age; string sex;&#125;;//冒泡排序void bubbleSort(hero arr[] , int len)&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j].age &gt; arr[j + 1].age) &#123; hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组void printHeros(hero arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; &#125;&#125;int main() &#123; struct hero arr[5] = &#123; &#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;, &#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;, &#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;, &#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;, &#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;, &#125;; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(&quot;pause&quot;); return 0;&#125; C++基础篇结束","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"结构体","slug":"结构体","permalink":"https://jinbilianshao.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"七.指针","date":"2023-03-01T11:30:00.000Z","path":"wiki/七。指针/","text":"7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： 123456789101112131415161718192021int main() &#123; //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： 1234567891011121314151617int main() &#123; int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：所有指针类型在32位操作系统下是4个字节 7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 12345678910111213int main() &#123; //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 野指针：指针变量指向非法的内存空间 示例2：野指针 123456789101112int main() &#123; //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 7.5 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： 12345678910111213141516171819202122232425int main() &#123; int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(&quot;pause&quot;); return 0;&#125; 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组作用：利用指针访问数组中元素 示例： 1234567891011121314151617181920int main() &#123; int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; int * p = arr; //指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; &#125; system(&quot;pause&quot;); return 0;&#125; 7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： 12345678910111213141516171819202122232425262728293031//值传递void swap1(int a ,int b)&#123; int temp = a; a = b; b = temp;&#125;//地址传递void swap2(int * p1, int *p2)&#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;int main() &#123; int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： 123456789101112131415161718192021222324252627282930313233343536373839//冒泡排序函数void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[]&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组函数void printArray(int arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;int main() &#123; int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0;&#125; 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"指针","slug":"指针","permalink":"https://jinbilianshao.github.io/tags/%E6%8C%87%E9%92%88/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"六.函数","date":"2023-03-01T11:23:00.000Z","path":"wiki/六-函数/","text":"6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 12345678返回值类型 函数名 （参数列表）&#123; 函数体语句 return表达式&#125; 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 123456//函数定义int add(int num1, int num2)&#123; int sum = num1 + num2; return sum;&#125; 6.3 函数的调用功能：使用定义好的函数 语法： 函数名（参数） 示例： 12345678910111213141516171819202122232425//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参&#123; int sum = num1 + num2; return sum;&#125;int main() &#123; int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，==如果形参发生，并不会影响实参== 示例： 12345678910111213141516171819202122232425262728293031void swap(int num1, int num2)&#123; cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return&#125;int main() &#123; int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： 123456789101112131415161718192021222324252627282930//函数常见样式//1、 无参无返void test01()&#123; //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; //test01(); 函数调用&#125;//2、 有参无返void test02(int a)&#123; cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;&#125;//3、无参有返int test03()&#123; cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10;&#125;//4、有参有返int test04(int a, int b)&#123; cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum = a + b; return sum;&#125; 6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： 123456789101112131415161718192021//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main() &#123; int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 6.7 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： 1234567//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b); 123456789101112//swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; 12345678910111213//main函数文件#include &quot;swap.h&quot;int main() &#123; int a = 100; int b = 200; swap(a, b); system(&quot;pause&quot;); return 0;&#125;","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"函数","slug":"函数","permalink":"https://jinbilianshao.github.io/tags/%E5%87%BD%E6%95%B0/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"五.数组","date":"2023-03-01T11:16:00.000Z","path":"wiki/五-数组/","text":"5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个==数据元素都是相同的数据类型== 特点2：数组是由==连续的内存==位置组成的 5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;; 数据类型 数组名[ ] = &#123; 值1，值2 ...&#125;; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445int main() &#123; //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = &#123;值1，值2 ，值3 ...&#125;; //如果&#123;&#125;内不足10个数据，剩余数据用0补全 int score2[10] = &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; score2[i] &lt;&lt; endl; &#125; //定义方式3 //数据类型 数组名[] = &#123;值1，值2 ，值3 ...&#125;; int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; score3[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： 12345678910111213141516171819202122int main() &#123; //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0;&#125; 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 代码实现 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[5] = &#123; 300, 350, 200, 400, 250 &#125;; int heaviest = 0; for (int i = 0; i &lt; 5; i++) &#123; if (arr[i] &gt; heaviest) &#123; heaviest = arr[i]; &#125; &#125; cout &lt;&lt; &quot;最重的小猪体重为：&quot; &lt;&lt; heaviest &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 代码实现： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int a[5] = &#123; 1,2,3,5,4 &#125;; int b[5]; for (int i = 0; i&lt;=4; i++) &#123; b[4 - i] = a[i]; &#125; for (int i= 0; i &lt; 5; i++) &#123; cout &lt;&lt; b[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 1234567891011121314151617181920212223242526int main() &#123; int arr[9] = &#123; 4,2,8,0,5,7,1,3,9 &#125;; for (int i = 0; i &lt; 9 - 1; i++) &#123; for (int j = 0; j &lt; 9 - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 5.3 二维数组二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; 数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;; 数据类型 数组名[ ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;; 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性== 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041int main() &#123; //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //方式2 //数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; int arr2[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; //方式3 //数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr3[2][3] = &#123; 1,2,3,4,5,6 &#125;; //方式4 //数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr4[][3] = &#123; 1,2,3,4,5,6 &#125;; system(&quot;pause&quot;); return 0;&#125; 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： 12345678910111213141516171819202122232425262728int main() &#123; //二维数组数组名 int arr[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： 12345678910111213141516171819202122232425int main() &#123; int scores[3][3] = &#123; &#123;100,100,100&#125;, &#123;90,50,100&#125;, &#123;60,70,80&#125;, &#125;; string names[3] = &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;; for (int i = 0; i &lt; 3; i++) &#123; int sum = 0; for (int j = 0; j &lt; 3; j++) &#123; sum += scores[i][j]; &#125; cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125;","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"数组","slug":"数组","permalink":"https://jinbilianshao.github.io/tags/%E6%95%B0%E7%BB%84/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"四.程序流程结构","date":"2023-03-01T11:03:00.000Z","path":"wiki/四-程序流程结构/","text":"4 程序流程结构C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构== 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构4.1.1 if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125; 示例： 12345678910111213141516171819202122int main() &#123; //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 注意：if条件表达式后不要加分号 多行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;; 示例： 123456789101112131415161718192021int main() &#123; int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 多条件的if语句：if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125; 示例： 1234567891011121314151617181920212223242526272829 int main() &#123; int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142int main() &#123; int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std; int main()&#123;//三只小猪称体重 //变量初始化三只小猪的体重 int pig1 = 0; int pig2 = 0; int pig3 = 0;//让用户输入小猪的重量 cout &lt;&lt; &quot;请输入小猪1的体重：&quot;&lt;&lt;endl; cin &gt;&gt; pig1; cout &lt;&lt; &quot;请输入小猪2的体重：&quot;&lt;&lt;endl; cin &gt;&gt; pig2; cout &lt;&lt; &quot;请输入小猪3的体重：&quot;&lt;&lt;endl; cin &gt;&gt; pig3; cout &lt;&lt; &quot;小猪1的体重为：&quot; &lt;&lt; pig1 &lt;&lt; &quot;斤&quot; &lt;&lt;endl; cout &lt;&lt; &quot;小猪2的体重为：&quot; &lt;&lt; pig2 &lt;&lt; &quot;斤&quot; &lt;&lt;endl; cout &lt;&lt; &quot;小猪3的体重为：&quot; &lt;&lt; pig3 &lt;&lt; &quot;斤&quot; &lt;&lt;endl;//判断哪支小猪是最重的 //先判断A和B的体重 if(pig1 &gt; pig2) //A和B比重 &#123; //A比B重 if(pig1 &gt; pig3) &#123; // A比C重 cout &lt;&lt;&quot;小猪1最重&quot;&lt;&lt;endl; &#125; else &#123; cout &lt;&lt;&quot;小猪3最重&quot;&lt;&lt;endl; &#125; &#125; else&#123; //B比A重 if(pig2 &gt; pig3) &#123; cout &lt;&lt;&quot;小猪2最重&quot;&lt;&lt;endl; &#125; else&#123; cout &lt;&lt;&quot;小猪3最重&quot;&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 4.1.2 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： 123456789101112131415161718192021int main() &#123; int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句作用：执行多条件分支语句 语法： 1234567891011121314switch(表达式)&#123; case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break;&#125; 示例： 12345678910111213141516171819202122232425262728293031323334int main() &#123; //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) &#123; case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; &#125; system(&quot;pause&quot;); return 0;&#125; 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句 语法： while(循环条件)&#123; 循环语句 &#125; 解释：==只要循环条件的结果为真，就执行循环语句== 示例： 12345678910111213int main() &#123; int num = 0; while (num &lt; 10) &#123; cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; num++; &#125; system(&quot;pause&quot;); return 0;&#125; 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：==猜数字== 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 代码实现如下： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;//time系统时间头文件包含#include &lt;ctime&gt;int main() &#123; //添加随机数种子 利用当前系统时间生成随机数，防止每次随机数都一样 srand((unsigned int)time(NULL)); //1.系统生成随机数 int num=rand()%100+1; // rand()%100 生成0+1~99+1的随机数 cout&lt;&lt;num&lt;&lt;endl; //2.玩家进行猜测 int val=0; while(1)&#123; cin&gt;&gt;val; //3.判断玩家的猜测 if(val&gt;num)&#123; //猜错 提示猜的结果 过大或者过小 重新返回第2步 cout&lt;&lt;&quot;猜测过大&quot;&lt;&lt;endl; &#125;else if(val&lt;num)&#123; //猜错 提示猜的结果 过大或者过小 重新返回第2步 cout&lt;&lt;&quot;猜测过小&quot;&lt;&lt;endl; &#125;else&#123; //猜对 退出游戏 cout&lt;&lt;&quot;恭喜您猜对啦&quot;&lt;&lt;endl; break; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do&#123; 循环语句 &#125; while(循环条件); 注意：与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件 示例： 12345678910111213141516int main() &#123; int num = 0; do &#123; cout &lt;&lt; num &lt;&lt; endl; num++; &#125; while (num &lt; 10); system(&quot;pause&quot;); return 0;&#125; 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 代码实现： 方法一 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; int main(int argc, const char * argv[]) &#123; int n, unit, ten, hund; // unit, ten, hund分别存储个位、十位和百位的数字 for(n = 100; n &lt; 1000; n++) &#123; unit = n % 10; // 得到n的个位数字 ten = (n / 10) % 10; // 得到n的十位数字 hund = n / 100; // 得到n的百位数字 // 判断各位数字的立方和是否等于它本身 if(n == hund * hund * hund + ten * ten * ten + unit * unit * unit) // if(n == pow(hund, 3) + pow(ten, 3) + pow(unit, 3)) cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 方法二 12345678910111213141516#include &lt;iostream&gt;using namespace std; int main(int argc, const char * argv[]) &#123; int sum; for(int i = 1; i &lt; 10; i++) for(int j = 0; j &lt; 10; j++) for(int k = 0; k &lt; 10; k++) &#123; sum = i * 100 + j * 10 + k; if(sum == (i * i * i + j * j * j + k * k * k)) cout &lt;&lt; sum &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; do…while实现 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main() &#123; int num = 100; do &#123; int a = num % 10; int b = (num % 100) / 10; int c = num / 100; if (a*a*a + b*b*b + c*c*c == num) &#123; cout &lt;&lt; &quot;水仙数是：&quot; &lt;&lt; num &lt;&lt; endl; &#125; num++; &#125; while (num &lt; 999); system(&quot;pause&quot;); return 0;&#125; 4.2.3 for循环语句作用： 满足循环条件，执行循环语句 语法： for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125; 示例： 1234567891011int main() &#123; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 代码实现 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std; int main() &#123; int num; for (num = 1; num&lt;= 100; num++) &#123; if (num &lt; 10) if (num == 7 || num % 7 == 0) cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; endl; else if (num &lt; 100) if (num % 10 == 7 || num / 10 == 7 || num % 7 == 0) cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; endl; else if (num % 10 == 7 || (num / 10) % 10 == 7 || num % 7 == 0) cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： 12345678910111213141516int main() &#123; //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 代码实现 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main() &#123; //嵌套循环实现九九乘法表 for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cout &lt;&lt;i&lt;&lt; &quot; * &quot;&lt;&lt;j&lt;&lt;&quot; = &quot;&lt;&lt;i * j&lt;&lt;&quot; &quot;; &#125; cout &lt;&lt; endl;//换行 &#125; system(&quot;pause&quot;); return 0;&#125; 4.3 跳转语句4.3.1 break语句作用: 用于跳出==选择结构==或者==循环结构== break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： 12345678910111213141516171819202122232425262728int main() &#123; //1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) &#123; case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; &#125; system(&quot;pause&quot;); return 0;&#125; 示例2： 123456789101112131415int main() &#123; //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; break; //跳出循环语句 &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 示例3： 12345678910111213141516171819int main() &#123; //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; if (j == 5) &#123; break; &#125; cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 4.3.2 continue语句作用：在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： 123456789101112131415int main() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; continue; &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： 123456789101112131415161718int main() &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：在程序中不建议使用goto语句，以免造成程序流程混乱","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"流程结构","slug":"流程结构","permalink":"https://jinbilianshao.github.io/tags/%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"三.运算符","date":"2023-03-01T11:00:00.000Z","path":"wiki/三-运算符/","text":"3 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： 1234567891011121314151617181920212223242526272829//加减乘除int main() &#123; int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：在除法运算中，除数不能为0 示例2： 1234567891011121314151617181920212223242526272829//取模int main() &#123; int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：只有整型变量可以进行取模运算 示例3： 1234567891011121314151617181920212223242526272829//递增int main() &#123; //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： 1234567891011121314151617181920212223242526272829303132333435363738int main() &#123; //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： 123456789101112131415161718192021int main() &#123; int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;&#125; 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 12345678910111213//逻辑运算符 --- 非int main() &#123; int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;&#125; 总结： 真变假，假变真 示例2：逻辑与 1234567891011121314151617181920212223//逻辑运算符 --- 与int main() &#123; int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;&#125; 总结：逻辑==与==运算符总结： ==同真为真，其余为假== 示例3：逻辑或 12345678910111213141516171819202122//逻辑运算符 --- 或int main() &#123; int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;&#125; 逻辑==或==运算符总结： ==同假为假，其余为真==","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"运算符","slug":"运算符","permalink":"https://jinbilianshao.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"二.数据类型","date":"2023-03-01T10:57:00.000Z","path":"wiki/二-数据类型/","text":"2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型作用：整型变量表示的是==整数类型==的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字作用：利用sizeof关键字可以==统计数据类型所占内存大小== 语法： sizeof( 数据类型 / 变量) 示例： 1234567891011121314int main() &#123; cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 整型结论：==short &lt; int &lt;= long &lt;= long long== 2.3 实型（浮点型）作用：用于==表示小数== 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： 12345678910111213141516171819202122int main() &#123; float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.4 字符型作用：字符型变量用于显示单个字符 语法：char ch = &#39;a&#39;; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用==1个字节==。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： 1234567891011121314151617int main() &#123; char ch = &#x27;a&#x27;; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = &quot;abcde&quot;; //错误，不可以用双引号 //ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符作用：用于表示一些==不能显示出来的ASCII字符== 现阶段我们常用的转义字符有： \\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 *\\\\* 代表一个反斜线字符”&quot; 092 &#39; 代表一个单引号（撇号）字符 039 &quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： 1234567891011int main() &#123; cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.6 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： 123456789int main() &#123; char str1[] = &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： 123456789int main() &#123; string str = &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;== 2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占==1个字节==大小 示例： 1234567891011121314int main() &#123; bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(&quot;pause&quot;); return 0;&#125; 2.8 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： 12345678910111213141516171819202122232425262728293031323334int main()&#123; //整型输入 int a = 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS;&#125;","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"数据类型","slug":"数据类型","permalink":"https://jinbilianshao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]},{"title":"一.C++初识","date":"2023-02-27T09:59:00.000Z","path":"wiki/C/","text":"1 C++初识1.1 第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码1234567891011#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 1.1.4 运行程序 1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 ==通常在文件上方定义==，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改 示例： 123456789101112131415161718//1、宏常量#define day 7int main() &#123; cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(&quot;pause&quot;); return 0;&#125; 1.5 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读","tags":[{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"变量常量标识符","slug":"变量常量标识符","permalink":"https://jinbilianshao.github.io/tags/%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E6%A0%87%E8%AF%86%E7%AC%A6/"}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"..","slug":"","permalink":"https://jinbilianshao.github.io/categories/"},{"name":"常用工具","slug":"/常用工具","permalink":"https://jinbilianshao.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"cmake","slug":"/cmake","permalink":"https://jinbilianshao.github.io/categories/cmake/"},{"name":"第一章：从简单的可执行文件到库","slug":"/cmake/第一章：从简单的可执行文件到库","permalink":"https://jinbilianshao.github.io/categories/cmake/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93/"},{"name":"git","slug":"/git","permalink":"https://jinbilianshao.github.io/categories/git/"},{"name":"C++","slug":"/C","permalink":"https://jinbilianshao.github.io/categories/C/"},{"name":"C++基础教程","slug":"/C/C-基础教程","permalink":"https://jinbilianshao.github.io/categories/C/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"vi","slug":"vi","permalink":"https://jinbilianshao.github.io/tags/vi/"},{"name":"cmake","slug":"cmake","permalink":"https://jinbilianshao.github.io/tags/cmake/"},{"name":"git","slug":"git","permalink":"https://jinbilianshao.github.io/tags/git/"},{"name":"c++","slug":"c","permalink":"https://jinbilianshao.github.io/tags/c/"},{"name":"结构体","slug":"结构体","permalink":"https://jinbilianshao.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"指针","slug":"指针","permalink":"https://jinbilianshao.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"函数","slug":"函数","permalink":"https://jinbilianshao.github.io/tags/%E5%87%BD%E6%95%B0/"},{"name":"数组","slug":"数组","permalink":"https://jinbilianshao.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"流程结构","slug":"流程结构","permalink":"https://jinbilianshao.github.io/tags/%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"},{"name":"运算符","slug":"运算符","permalink":"https://jinbilianshao.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"数据类型","slug":"数据类型","permalink":"https://jinbilianshao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"变量常量标识符","slug":"变量常量标识符","permalink":"https://jinbilianshao.github.io/tags/%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E6%A0%87%E8%AF%86%E7%AC%A6/"}]}